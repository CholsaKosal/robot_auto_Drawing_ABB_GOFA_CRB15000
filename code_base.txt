.
├── InputDrawing.mod
├── main.py
├── README.md
└── testing
    ├── devnote.md
    ├── main.py
    ├── main_without_D.py
    ├── main_without_R.py
    ├── rapid_code.mod
    ├── rapid_code_no_D.mod
    ├── rapid_code_no_R.mod
    ├── README.md
    ├── test_main_gui.py
    └── test_main_itworks_A4_GG.py

2 directories, 13 files


=======================================
          FILE CONTENTS START HERE         
=======================================

--- START OF FILE: testing/devnote.md ---
There is a **major potential advantage** to removing the "Done" (`D`) acknowledgement, but it comes with a significant trade-off in robustness.

Here’s the breakdown:

### The Advantage: Speed and Fluid Motion (Streaming)

By removing the `SocketSend` for "D" and the corresponding `receive` call in Python, you change the protocol from a **synchronous "lock-step" system** to an **asynchronous "streaming" system**.

* **Current "Lock-Step" Method:** The Python script sends a command and then waits until the robot has physically **finished** the movement before it sends the next command. This is very safe but can result in choppy or slow movements, as the robot comes to a brief stop after every single `MoveL` command to wait for the next instruction.

* **Proposed "Streaming" Method:** If you remove the "D" acknowledgement, the Python script only waits for the "Ready" (`R`) confirmation. This confirmation simply means "I have received and understood the command." The Python script can then immediately send the *next* command while the robot is still busy executing the *previous* one.

The robot controller has an internal buffer and can queue up these incoming movement commands. This allows the controller to blend the movements together, resulting in a much faster, smoother, and more continuous drawing path. This is the single biggest advantage.

### The Disadvantage: Risk and Loss of Synchronization

The "Done" (`D`) acknowledgement provides a crucial piece of information: **positive confirmation that the requested task was completed successfully.** Removing it introduces risks:

* **Buffer Overflow:** The Python script could potentially send commands much faster than the robot can execute them. This could overwhelm the robot controller's movement buffer, leading to errors or unpredictable behavior. The "Done" acknowledgement acts as a natural rate limiter, preventing this from ever happening.

* **Loss of State Tracking:** You no longer know for certain that a move has been completed. If the robot encounters a physical obstruction or an error during a move, the Python script will be "flying blind," unaware of the problem, and will continue sending more commands. This makes error recovery and features like "reconnect and resume" much more difficult to implement reliably.

### Conclusion: Is it worth it?

It's a classic trade-off between **speed and safety**.

* For applications where **absolute certainty and simple error recovery** are paramount, the current lock-step protocol with both "Ready" and "Done" acknowledgements is superior.
* For an application like **drawing**, where speed and smooth, continuous motion are highly desirable, moving to a streaming protocol by removing the "Done" acknowledgement is often the right choice.

To do it safely, you would typically implement a more advanced flow control mechanism. For example, instead of sending one command at a time, you could send a small batch (e.g., 10 commands), wait for all 10 "Ready" acknowledgements, and then send the next batch. This keeps the robot's buffer full enough for smooth motion but prevents it from overflowing.
--- END OF FILE: testing/devnote.md ---
--- START OF FILE: testing/main_without_D.py ---
import tkinter as tk
from tkinter import messagebox, filedialog, ttk
import os
import threading
import time
import logging
import socket
import struct # Import the struct module for packing data
from concurrent.futures import ThreadPoolExecutor
from typing import List, Tuple, Optional
import cv2
import numpy as np
import math
from PIL import Image, ImageTk

# Configure logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")

# --- Constants (Consolidated) ---
SCRIPT_DIR = os.getenv("SCRIPT_DIR", ".")
DATA_DIR = os.getenv("DATA_DIR", ".")

TMP_CAPTURE_PATH = os.path.join(DATA_DIR, "temp_capture.png")
TMP_EDGE_OUTPUT_PATH = os.path.join(DATA_DIR, "temp_edges_{}.png")

REAL_ROBOT_HOST = '192.168.125.1'
REAL_ROBOT_PORT = 1025
SIMULATION_HOST = '127.0.0.1'
SIMULATION_PORT = 55000

# Drawing Specific Constants
# Standardized to (X, Y, Z)
FINAL_ROBOT_POSITION = (0, 0, -350)
A4_WIDTH_MM = 180
A4_HEIGHT_MM = 217
# This is now a DEFAULT value, which can be overridden by the GUI.
PEN_DOWN_Z = -14 
PEN_UP_Z = 1.3 * PEN_DOWN_Z 
MIN_CONTOUR_LENGTH_PX = 10

# Threshold options
THRESHOLD_OPTIONS = [
    ("Option {}".format(i), i*10, i*20) for i in range(1, 8)
]

# Time estimation factor
TIME_ESTIMATE_FACTOR = 0.018

# Waypoints for the signature drawing, using specific Z-depths.
SIGNATURE_WAYPOINTS = ((0, 0, -70),)


def create_signature_commands(waypoints, pen_down_z):
    """Converts signature waypoints into robot commands, handling pen up/down moves."""
    pen_up_z = 1.3 * pen_down_z
    if pen_up_z == 0:
        pen_up_z = -3
    commands = []
    if not waypoints:
        return commands

    # Move to the starting XY of the signature with the pen up
    start_x, start_y, _ = waypoints[0]
    commands.append((start_x, start_y, pen_up_z))

    # Add the actual drawing waypoints
    for point in waypoints:
        commands.append(point)

    # Lift the pen at the end of the signature
    if commands:
        last_x, last_y, _ = waypoints[-1]
        commands.append((last_x, last_y, pen_up_z))
    return commands


def calculate_distance(p1, p2):
    """Calculates Euclidean distance between two points (x, y)."""
    if p1 is None or p2 is None: return float('inf')
    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)


def image_to_contours_internal(image_path_or_array, threshold1, threshold2, save_edge_path=None):
    if isinstance(image_path_or_array, str):
        image = cv2.imread(image_path_or_array, cv2.IMREAD_GRAYSCALE)
    elif isinstance(image_path_or_array, np.ndarray):
        if len(image_path_or_array.shape) == 3:
            image = cv2.cvtColor(image_path_or_array, cv2.COLOR_BGR2GRAY)
        else:
            image = image_path_or_array
    else:
        logging.error("Invalid input type for image_to_contours_internal")
        return None, 0, 0

    if image is None:
        logging.error(f"Could not read or process image input.")
        return None, 0, 0

    image_height, image_width = image.shape[:2]
    if image_height == 0 or image_width == 0:
        logging.error("Invalid image dimensions.")
        return None, 0, 0

    blurred = cv2.GaussianBlur(image, (5, 5), 0)
    edges = cv2.Canny(blurred, threshold1, threshold2)

    if save_edge_path:
        try:
            cv2.imwrite(save_edge_path, edges)
        except Exception as e:
            logging.error(f"Failed to save edge image to {save_edge_path}: {e}")

    contours, _ = cv2.findContours(edges, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)
    filtered_contours = [c for c in contours if cv2.arcLength(c, closed=False) > MIN_CONTOUR_LENGTH_PX]

    contours_xy = []
    for contour in filtered_contours:
        points = contour.squeeze().tolist()
        if not isinstance(points, list) or not points: continue
        if isinstance(points[0], int):
            points = [points]
        contours_xy.append([(p[0], p[1]) for p in points if isinstance(p, (list, tuple)) and len(p) == 2])

    contours_xy = [c for c in contours_xy if c]
    return contours_xy, image_width, image_height


def scale_point_to_a4(point_xy, image_width, image_height, scale_factor):
    x_pixel, y_pixel = point_xy
    center_x_pixel = image_width / 2
    center_y_pixel = image_height / 2
    x_centered_pixel = x_pixel - center_x_pixel
    y_centered_pixel = center_y_pixel - y_pixel
    x_mm = x_centered_pixel * scale_factor
    y_mm = y_centered_pixel * scale_factor
    return (x_mm, y_mm)


def create_drawing_paths(contours_xy, image_width, image_height, pen_down_z, optimize_paths=True):
    """Generates robot drawing paths using a specific Z-height for pen-down moves."""
    if not contours_xy or image_width <= 0 or image_height <= 0:
        return []

    pen_up_z = 1.3 * pen_down_z
    if pen_up_z == 0:
        pen_up_z = -3

    scale_x = A4_WIDTH_MM / image_width
    scale_y = A4_HEIGHT_MM / image_height
    scale_factor = min(scale_x, scale_y)

    scaled_contours = []
    for contour in contours_xy:
        if not contour: continue
        scaled_contour = [scale_point_to_a4(p, image_width, image_height, scale_factor) for p in contour]
        if len(scaled_contour) >= 2:
            scaled_contours.append(scaled_contour)
        elif len(scaled_contour) == 1:
            scaled_contours.append([scaled_contour[0], scaled_contour[0]])

    if not scaled_contours:
        return []

    ordered_contours = []
    last_point = None
    if optimize_paths:
        remaining_contours = list(scaled_contours)
        if remaining_contours:
            current_contour = remaining_contours.pop(0)
            ordered_contours.append(current_contour)
            last_point = current_contour[-1]

            while remaining_contours:
                best_dist = float('inf')
                best_idx = -1
                best_reversed = False

                for i, contour in enumerate(remaining_contours):
                    start_point = contour[0]
                    end_point = contour[-1]
                    dist_start = calculate_distance(last_point, start_point)
                    dist_end = calculate_distance(last_point, end_point)

                    if dist_start < best_dist:
                        best_dist = dist_start
                        best_idx = i
                        best_reversed = False
                    if dist_end < best_dist:
                        best_dist = dist_end
                        best_idx = i
                        best_reversed = True

                if best_idx != -1:
                    next_contour = remaining_contours.pop(best_idx)
                    if best_reversed:
                        next_contour.reverse()
                    ordered_contours.append(next_contour)
                    last_point = next_contour[-1]
                else:
                    logging.warning("Path optimization loop finished unexpectedly.")
                    break
        scaled_contours = ordered_contours
    else:
        scaled_contours = [c for c in scaled_contours]

    robot_commands = []
    for contour in scaled_contours:
        if not contour: continue
        start_point = contour[0]
        # Standardized to (X, Y, Z)
        robot_commands.append((start_point[0], start_point[1], pen_up_z))
        robot_commands.append((start_point[0], start_point[1], pen_down_z))

        for i in range(len(contour) - 1):
            end_point = contour[i+1]
            if end_point != contour[i]:
                # Standardized to (X, Y, Z)
                robot_commands.append((end_point[0], end_point[1], pen_down_z))

        final_point = contour[-1]
        # Standardized to (X, Y, Z)
        robot_commands.append((final_point[0], final_point[1], pen_up_z))

    return robot_commands


class RUNME_GUI:
    """Main GUI application for the Robotics System."""

    def __init__(self):
        self.window = tk.Tk()
        self.window.title("Robotics Drawing GUI")
        self.main_frame = tk.Frame(self.window)
        self.main_frame.pack(pady=20, padx=20, fill="both", expand=True)

        self.connection_var = tk.StringVar(value="simulation")
        self.socket = None
        self.connected = False
        self.connection_established = False

        self.cap = None
        self.camera_running = False
        self.camera_frame_label = None
        self.capture_button = None
        self.camera_back_button = None

        self.current_image_path = None
        self.threshold_options_data = {}
        self.selected_commands = None
        self.drawing_in_progress = False
        self.cancel_requested = False
        self.progress_bar = None
        self.status_label = None
        self.cancel_button = None
        self.reconnect_button = None
        
        self.test_z_var = tk.StringVar(value=str(PEN_DOWN_Z))
        
        self.pause_event = threading.Event()
        self.pause_resume_button = None

        self.last_drawing_status = {
            "total_commands": 0,
            "completed_commands": 0,
            "status": "None",
            "error_message": ""
        }
        
        self.resume_needed = False
        self.resume_commands = None
        self.resume_total_original_commands = 0
        self.resume_start_index_global = 0

        # --- ETA Countdown variables ---
        self.eta_update_id = None
        self.drawing_start_time = 0
        self.total_paused_time = 0
        self.pause_start_time = 0
        self.progress_text_var = tk.StringVar()


        self.main_page()

    def main_page(self):
        self.clear_frame()
        tk.Label(self.main_frame, text="Robotics Drawing System", font=("Arial", 16)).pack(pady=10)
        tk.Button(self.main_frame, text="Setup Connection & Draw",
                  command=self.connection_setup_page, width=30).pack(pady=5)
        tk.Button(self.main_frame, text="Exit",
                  command=self.on_window_close, width=30).pack(pady=5)

    def connection_setup_page(self):
        self.clear_frame()
        tk.Label(self.main_frame, text="Robot Connection Setup", font=("Arial", 16)).pack(pady=10)

        connection_frame = tk.Frame(self.main_frame)
        connection_frame.pack(pady=10)
        tk.Radiobutton(connection_frame, text=f"Simulation: {SIMULATION_HOST}:{SIMULATION_PORT}",
                       variable=self.connection_var, value="simulation").pack(anchor='w')
        tk.Radiobutton(connection_frame, text=f"Real Robot: {REAL_ROBOT_HOST}:{REAL_ROBOT_PORT}",
                       variable=self.connection_var, value="real").pack(anchor='w')

        self.connect_button = tk.Button(self.main_frame, text="Connect", command=self.establish_connection, width=20)
        self.reconnect_button = tk.Button(self.main_frame, text="Reconnect & Resume", command=self.establish_connection, width=20)

        if self.resume_needed:
            self.reconnect_button.pack(pady=5)
            tk.Label(self.main_frame, text="Connection lost during last drawing. Reconnect to resume.", fg="orange").pack()
        else:
            self.connect_button.pack(pady=5)

        tk.Button(self.main_frame, text="Back", command=self.main_page, width=20).pack(pady=5)

    def drawing_options_page(self):
        if not self.connection_established:
            messagebox.showerror("Connection Required", "Please establish connection first.")
            self.connection_setup_page()
            return

        self.clear_frame()
        tk.Label(self.main_frame, text="Robot Drawing Options", font=("Arial", 16)).pack(pady=10)
        conn_type = "Simulation" if self.connection_var.get() == "simulation" else "Real Robot"
        tk.Label(self.main_frame, text=f"Connected to: {conn_type}", fg="green").pack(pady=5)
        last_status = self.last_drawing_status["status"]
        if last_status not in ["None", "Completed"]:
            status_frame = tk.Frame(self.main_frame, relief=tk.RIDGE, borderwidth=2)
            status_frame.pack(pady=10, padx=10, fill='x')
            tk.Label(status_frame, text="Previous Drawing Status:", font=("Arial", 10, "bold")).pack(anchor='w')
            status_text = f"Status: {last_status}"
            if self.last_drawing_status["total_commands"] > 0:
                status_text += f" (Stopped at command {self.last_drawing_status['completed_commands'] + 1}" \
                               f" of {self.last_drawing_status['total_commands']})"
            tk.Label(status_frame, text=status_text).pack(anchor='w', padx=5)
            if self.last_drawing_status["error_message"]:
                tk.Label(status_frame, text=f"Details: {self.last_drawing_status['error_message']}", wraplength=400).pack(anchor='w', padx=5)

        test_z_frame = tk.Frame(self.main_frame, pady=5)
        test_z_frame.pack(pady=5)

        tk.Label(test_z_frame, text="Test / Drawing Z-Coordinate:").pack(side=tk.LEFT, padx=5)
        test_z_entry = tk.Entry(test_z_frame, textvariable=self.test_z_var, width=10)
        test_z_entry.pack(side=tk.LEFT)
        
        self.send_z_button = tk.Button(test_z_frame, text="Send to (0, 0, Z)", command=self.send_to_test_z_action)
        self.send_z_button.pack(side=tk.LEFT, padx=10)

        test_buttons_frame = tk.Frame(self.main_frame)
        test_buttons_frame.pack(pady=5)

        self.safe_center_button = tk.Button(test_buttons_frame, text="Go to Safe Center", command=self.send_to_safe_center_action, width=20)
        self.safe_center_button.pack(side=tk.LEFT, padx=5)

        self.test_workspace_button = tk.Button(test_buttons_frame, text="Test Workspace", command=self.test_workspace_action, width=20)
        self.test_workspace_button.pack(side=tk.LEFT, padx=5)

        tk.Button(self.main_frame, text="Capture Image to Draw",
                  command=self.capture_image_page, width=30).pack(pady=5)
        tk.Button(self.main_frame, text="Input Image to Draw",
                  command=self.input_image_page, width=30).pack(pady=5)
        
        tk.Button(self.main_frame, text="Disconnect",
                  command=self.close_and_return_main, width=30).pack(pady=5)

    def send_to_test_z_action(self):
        try:
            test_z = float(self.test_z_var.get())
        except ValueError:
            messagebox.showerror("Invalid Input", "The Z-coordinate must be a valid number.")
            return

        if self.send_z_button and self.send_z_button.winfo_exists():
            self.send_z_button.config(state=tk.DISABLED)
        # Standardized to (X, Y, Z)
        threading.Thread(target=self._send_command_sequence_thread, args=([(0.0, 0.0, test_z)], self.send_z_button), daemon=True).start()

    def send_to_safe_center_action(self):
        safe_z = 6 * PEN_DOWN_Z
        
        if hasattr(self, 'safe_center_button') and self.safe_center_button.winfo_exists():
            self.safe_center_button.config(state=tk.DISABLED)
        
        # Standardized to (X, Y, Z)
        logging.info(f"Sending robot to safe center (0, 0, {safe_z})")
        threading.Thread(target=self._send_command_sequence_thread, args=([(0, 0, safe_z)], self.safe_center_button), daemon=True).start()

    def test_workspace_action(self):
        """Sends the robot on a path to outline the workspace corners."""
        try:
            test_z = float(self.test_z_var.get())
        except ValueError:
            messagebox.showerror("Invalid Input", "The Z-coordinate for testing must be a valid number.")
            return

        if hasattr(self, 'test_workspace_button') and self.test_workspace_button.winfo_exists():
            self.test_workspace_button.config(state=tk.DISABLED)

        pen_up_z = 1.3 * test_z
        
        if pen_up_z == 0:
            pen_up_z = -3

        # Standardized to (X, Y, Z)
        workspace_path = [
            (0,0, test_z),
            (50, 50, test_z),
            (50, -50, test_z),
            (-50, -50, test_z),
            (-50, 50, test_z),
            (0,0, test_z),
            (0, 0, pen_up_z)
        ]
        
        logging.info("Starting workspace test...")
        
        threading.Thread(target=self._send_command_sequence_thread, args=(workspace_path, self.test_workspace_button), daemon=True).start()

    def _send_command_sequence_thread(self, commands: List[Tuple], button_to_re_enable: tk.Button):
        """Thread worker to send a sequence of commands, one by one, using the new byte protocol."""
        original_text = button_to_re_enable.cget("text")
        self.window.after(0, lambda: button_to_re_enable.config(text="Moving..."))

        # Standardized to (X, Y, Z)
        for i, (x, y, z) in enumerate(commands):
            if self.cancel_requested:
                logging.info("Test sequence cancelled.")
                break
            
            logging.info(f"Sending command {i+1}/{len(commands)}: ({x:.2f}, {y:.2f}, {z:.2f})")
            # Standardized to pack (X, Y, Z)
            byte_data = struct.pack('!fff', x, y, z)
            
            if self.send_message_internal(byte_data):
                response_r = self.receive_message_internal(timeout=5.0)
                if response_r == "R":
                    logging.info("Received 'R' (Ready) from robot.")
                    # response_d = self.receive_message_internal(timeout=None)
                    # if response_d == "D":
                    #     logging.info("Received 'D' (Done) from robot.")
                    # else:
                    #     error_msg = f"Robot did not confirm completion (D) for command {i+1}. Got: '{response_d}'"
                    #     logging.error(error_msg)
                    #     self.window.after(0, lambda: messagebox.showerror("Test Failed", error_msg))
                    #     break
                else:
                    error_msg = f"Robot did not confirm receipt (R) for command {i+1}. Got: '{response_r}'"
                    logging.error(error_msg)
                    self.window.after(0, lambda: messagebox.showerror("Test Failed", error_msg))
                    break
            else:
                self.window.after(0, lambda: messagebox.showerror("Connection Error", "Failed to send test command. Connection may be lost."))
                break
        
        if button_to_re_enable and button_to_re_enable.winfo_exists():
            self.window.after(0, lambda: button_to_re_enable.config(state=tk.NORMAL, text=original_text))
        logging.info(f"Sequence '{original_text}' finished.")


    def capture_image_page(self):
        self.clear_frame()
        tk.Label(self.main_frame, text="Camera View", font=("Arial", 16)).pack(pady=5)

        self.camera_frame_label = tk.Label(self.main_frame)
        self.camera_frame_label.pack(pady=10)

        button_frame = tk.Frame(self.main_frame)
        button_frame.pack(pady=5)

        self.capture_button = tk.Button(button_frame, text="Capture (S)", command=self.capture_action)
        self.capture_button.pack(side=tk.LEFT, padx=5)
        self.camera_back_button = tk.Button(button_frame, text="Back", command=self.stop_camera_and_go_back)
        self.camera_back_button.pack(side=tk.LEFT, padx=5)

        self.window.bind('s', self.capture_action_event)
        self.window.bind('S', self.capture_action_event)

        self.start_camera_feed()

    def start_camera_feed(self):
        if self.camera_running: return

        try:
            self.cap = cv2.VideoCapture(0)
            if not self.cap.isOpened():
                messagebox.showerror("Camera Error", "Could not open camera.")
                self.stop_camera_and_go_back()
                return
            self.camera_running = True
            self._update_camera_frame()
        except Exception as e:
            messagebox.showerror("Camera Error", f"Error initializing camera: {e}")
            self.stop_camera_and_go_back()

    def _update_camera_frame(self):
        if not self.camera_running or not self.cap:
            return

        ret, frame = self.cap.read()
        if ret:
            cv_image = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            pil_image = Image.fromarray(cv_image)
            imgtk = ImageTk.PhotoImage(image=pil_image)

            if self.camera_frame_label:
                self.camera_frame_label.imgtk = imgtk
                self.camera_frame_label.configure(image=imgtk)
        else:
            logging.warning("Failed to grab frame from camera.")

        if self.camera_running:
            self.window.after(30, self._update_camera_frame)

    def stop_camera_feed(self):
        self.camera_running = False
        time.sleep(0.1)
        if self.cap:
            self.cap.release()
            self.cap = None

    def stop_camera_and_go_back(self):
        self.stop_camera_feed()
        self.window.unbind('s')
        self.window.unbind('S')
        self.drawing_options_page()

    def capture_action_event(self, event=None):
        self.capture_action()

    def capture_action(self):
        if not self.camera_running or not self.cap:
            messagebox.showwarning("Capture Error", "Camera not running.")
            return

        ret, frame = self.cap.read()
        self.stop_camera_feed()
        self.window.unbind('s')
        self.window.unbind('S')

        if ret:
            try:
                os.makedirs(DATA_DIR, exist_ok=True)
                cv2.imwrite(TMP_CAPTURE_PATH, frame)
                logging.info(f"Image captured and saved to {TMP_CAPTURE_PATH}")
                self.current_image_path = TMP_CAPTURE_PATH
                self.show_threshold_options(self.current_image_path)
            except Exception as e:
                messagebox.showerror("Save Error", f"Could not save captured image: {e}")
                self.drawing_options_page()
        else:
            messagebox.showerror("Capture Error", "Failed to capture frame from camera.")
            self.drawing_options_page()

    def input_image_page(self):
        self.clear_frame()
        tk.Label(self.main_frame, text="Input Image to Draw", font=("Arial", 16)).pack(pady=10)

        entry_frame = tk.Frame(self.main_frame)
        entry_frame.pack(pady=5, fill='x', padx=10)
        tk.Label(entry_frame, text="Image Path:").pack(side=tk.LEFT)
        self.image_path_var = tk.StringVar()
        path_entry = tk.Entry(entry_frame, textvariable=self.image_path_var, width=50)
        path_entry.pack(side=tk.LEFT, fill='x', expand=True, padx=5)
        tk.Button(entry_frame, text="Browse...", command=self.browse_image_file).pack(side=tk.LEFT)

        tk.Button(self.main_frame, text="Process Image", command=self.process_input_image, width=20).pack(pady=10)
        tk.Button(self.main_frame, text="Back", command=self.drawing_options_page, width=20).pack(pady=10)

    def browse_image_file(self):
        filepath = filedialog.askopenfilename(
            title="Select Image to Draw",
            filetypes=[("Image Files", "*.png *.jpg *.jpeg *.bmp *.gif"), ("All Files", "*.*")]
        )
        if filepath:
            self.image_path_var.set(filepath)

    def process_input_image(self):
        filepath = self.image_path_var.get()
        if not filepath or not os.path.isfile(filepath):
            messagebox.showerror("Error", f"Invalid or non-existent file path:\n{filepath}")
            return
        self.current_image_path = filepath
        self.show_threshold_options(self.current_image_path)

    def show_threshold_options(self, image_path):
        self.clear_frame()
        tk.Label(self.main_frame, text="Select Drawing Style (Thresholds)", font=("Arial", 16)).pack(pady=10)

        self.threshold_options_data = {}
        self.selected_threshold_option = tk.StringVar(value=None)
        self.preview_label = tk.Label(self.main_frame)
        self.preview_label.pack(pady=5)

        options_frame = tk.Frame(self.main_frame)
        options_frame.pack(pady=5)

        loading_label = tk.Label(options_frame, text="Processing options...")
        loading_label.pack()
        self.window.update()

        try:
            pen_down_z = float(self.test_z_var.get())
            logging.info(f"Using custom pen down Z for drawing path generation: {pen_down_z}")
        except (ValueError, tk.TclError):
            logging.warning("Invalid or no custom Z value found, using default.")
            pen_down_z = PEN_DOWN_Z

        threading.Thread(target=self._process_threshold_options_thread, args=(image_path, options_frame, loading_label, pen_down_z), daemon=True).start()

    def _process_threshold_options_thread(self, image_path, options_frame, loading_label, pen_down_z):
        results = {}
        preview_paths = {}

        for i, (label, t1, t2) in enumerate(THRESHOLD_OPTIONS):
            logging.info(f"Processing option: {label} (t1={t1}, t2={t2})")
            preview_path = TMP_EDGE_OUTPUT_PATH.format(i)
            contours_xy, w, h = image_to_contours_internal(image_path, t1, t2, save_edge_path=preview_path)

            if contours_xy is None or w == 0 or h == 0:
                logging.warning(f"Failed to process contours for option {label}")
                results[label] = None
                preview_paths[label] = None
                continue

            commands = create_drawing_paths(contours_xy, w, h, pen_down_z, optimize_paths=True)
            if commands:
                num_commands = len(commands)
                est_time_sec = num_commands * TIME_ESTIMATE_FACTOR
                est_time_min = est_time_sec / 60
                results[label] = {
                    "commands": commands,
                    "count": num_commands,
                    "time_str": f"{est_time_min:.1f} min",
                    "t1": t1,
                    "t2": t2
                }
                preview_paths[label] = preview_path if os.path.exists(preview_path) else None
            else:
                results[label] = None
                preview_paths[label] = None
                logging.warning(f"No commands generated for option {label}")

        self.window.after(0, lambda: self._display_threshold_options(options_frame, loading_label, results, preview_paths))

    def _display_threshold_options(self, options_frame, loading_label, results, preview_paths):
        loading_label.destroy()

        self.threshold_options_data = results
        self.edge_preview_paths = preview_paths

        default_selected = False
        for i, (label, t1, t2) in enumerate(THRESHOLD_OPTIONS):
            option_data = results.get(label)
            if option_data:
                count = option_data["count"]
                time_str = option_data["time_str"]
                radio_text = f"{label} (t1={t1}, t2={t2}) - Cmds: {count}, Est: {time_str}"
                rb = tk.Radiobutton(
                    options_frame,
                    text=radio_text,
                    variable=self.selected_threshold_option,
                    value=label,
                    command=lambda l=label: self.show_edge_preview(l)
                )
                rb.pack(anchor='w')
                if not default_selected:
                    self.selected_threshold_option.set(label)
                    self.show_edge_preview(label)
                    default_selected = True
            else:
                tk.Label(options_frame, text=f"{label} (t1={t1}, t2={t2}) - No drawing generated", fg="gray").pack(anchor='w')

        button_frame = tk.Frame(self.main_frame)
        button_frame.pack(pady=10)
        tk.Button(button_frame, text="Confirm and Draw", command=self.confirm_and_start_drawing, width=20).pack(side=tk.LEFT, padx=5)
        tk.Button(button_frame, text="Save Points to File", command=self.save_points_to_file, width=20).pack(side=tk.LEFT, padx=5)
        tk.Button(button_frame, text="Back", command=self.drawing_options_page, width=20).pack(side=tk.LEFT, padx=5)

    def save_points_to_file(self):
        """Saves the generated drawing commands for the selected option to a text file."""
        selected_label = self.selected_threshold_option.get()
        if not selected_label:
            messagebox.showwarning("Selection Needed", "Please select a drawing style option first.")
            return

        option_data = self.threshold_options_data.get(selected_label)
        if not option_data or not option_data.get("commands"):
            messagebox.showerror("Error", "Selected option has no drawing commands to save.")
            return

        commands = option_data["commands"]
        
        filepath = filedialog.asksaveasfilename(
            title="Save Drawing Points",
            defaultextension=".txt",
            filetypes=[("Text Files", "*.txt"), ("All Files", "*.*")],
            initialfile="drawing_points.txt"
        )

        if not filepath:
            # User cancelled the save dialog
            return

        try:
            with open(filepath, 'w') as f:
                # Format as a tuple of tuples: ((x,y,z),(x,y,z),...)
                points_str = ",".join([f"({x:.2f},{y:.2f},{z:.2f})" for x, y, z in commands])
                f.write(f"({points_str})")
            
            messagebox.showinfo("Success", f"Drawing points successfully saved to:\n{filepath}")
        except Exception as e:
            messagebox.showerror("Save Error", f"Could not save the file.\nError: {e}")

    def show_edge_preview(self, option_label):
        preview_path = self.edge_preview_paths.get(option_label)
        if preview_path and os.path.exists(preview_path):
            try:
                img = Image.open(preview_path)
                img.thumbnail((300, 300))
                imgtk = ImageTk.PhotoImage(image=img)
                self.preview_label.imgtk = imgtk
                self.preview_label.configure(image=imgtk)
            except Exception as e:
                logging.error(f"Error loading preview image {preview_path}: {e}")
                self.preview_label.configure(image=None, text="Preview error")
        else:
            self.preview_label.configure(image=None, text="No Preview")

    def confirm_and_start_drawing(self):
        selected_label = self.selected_threshold_option.get()
        if not selected_label:
            messagebox.showwarning("Selection Needed", "Please select a drawing style option.")
            return

        option_data = self.threshold_options_data.get(selected_label)
        if not option_data or not option_data.get("commands"):
            messagebox.showerror("Error", "Selected option has no drawing commands.")
            return

        self.selected_commands = option_data["commands"]

        if not self.drawing_in_progress:
            self.drawing_in_progress = True
            self.cancel_requested = False
            self.resume_needed = False
            self.pause_event.set()
            
            try:
                pen_down_z = float(self.test_z_var.get())
            except (ValueError, tk.TclError):
                pen_down_z = PEN_DOWN_Z

            full_command_list = self.selected_commands + create_signature_commands(SIGNATURE_WAYPOINTS, pen_down_z)
            
            # --- ETA Calculation ---
            self.total_estimated_time = len(full_command_list) * TIME_ESTIMATE_FACTOR
            self.drawing_start_time = time.time()
            self.total_paused_time = 0
            self.pause_start_time = 0
            
            threading.Thread(target=self.run_drawing_loop, args=(full_command_list,), daemon=True).start()
            self.show_drawing_progress_page(len(full_command_list))
        else:
            messagebox.showwarning("Busy", "Drawing already in progress.")

    def show_drawing_progress_page(self, total_commands, current_progress=0):
        self.clear_frame()
        tk.Label(self.main_frame, text="Drawing in Progress...", font=("Arial", 16)).pack(pady=10)

        self.status_label = tk.Label(self.main_frame, textvariable=self.progress_text_var)
        self.status_label.pack(pady=5)

        self.progress_bar = ttk.Progressbar(self.main_frame, orient="horizontal", length=300, mode="determinate", maximum=total_commands, value=current_progress)
        self.progress_bar.pack(pady=10)

        controls_frame = tk.Frame(self.main_frame)
        controls_frame.pack(pady=5)

        self.pause_resume_button = tk.Button(controls_frame, text="Pause", command=self.toggle_pause_resume, width=15)
        self.pause_resume_button.pack(side=tk.LEFT, padx=5)
        
        self.cancel_button = tk.Button(controls_frame, text="Cancel Drawing", command=self.request_cancel_drawing, width=15)
        self.cancel_button.pack(side=tk.LEFT, padx=5)

        # Start the ETA update loop
        self.update_drawing_status(current_progress, total_commands)
        self._update_eta_countdown()


    def _update_eta_countdown(self):
        """Periodically updates the ETA label with a dynamic estimate."""
        if not self.drawing_in_progress:
            return

        completed_cmds = self.progress_bar['value']
        total_cmds = self.progress_bar['maximum']
        
        remaining_time = 0
        
        # Only calculate dynamic ETA after a few commands have completed for stability
        if completed_cmds > 5:
            # Calculate total time spent actively drawing (excluding pauses)
            active_drawing_time = (time.time() - self.drawing_start_time) - self.total_paused_time
            avg_time_per_cmd = active_drawing_time / completed_cmds
            remaining_cmds = total_cmds - completed_cmds
            remaining_time = remaining_cmds * avg_time_per_cmd
        else:
            # For the beginning, use the initial static estimate
            elapsed_time = (time.time() - self.drawing_start_time) - self.total_paused_time
            initial_total_time = total_cmds * TIME_ESTIMATE_FACTOR
            remaining_time = initial_total_time - elapsed_time

        if remaining_time < 0:
            remaining_time = 0

        mins, secs = divmod(int(remaining_time), 60)
        time_str = f"{mins:02d}:{secs:02d}"
        
        # Update the full progress text
        self.progress_text_var.set(f"Sent {completed_cmds} / {total_cmds} commands | ETA: {time_str}")

        # Schedule the next update
        self.eta_update_id = self.window.after(1000, self._update_eta_countdown)


    def toggle_pause_resume(self):
        if self.pause_event.is_set():
            # --- PAUSING ---
            self.pause_event.clear()
            logging.info("Drawing paused by user.")
            if self.pause_resume_button and self.pause_resume_button.winfo_exists():
                self.pause_resume_button.config(text="Resume")
            
            # Record when the pause started
            self.pause_start_time = time.time()
            
            # Stop the timer when paused
            if self.eta_update_id:
                self.window.after_cancel(self.eta_update_id)
                self.eta_update_id = None
        else:
            # --- RESUMING ---
            self.pause_event.set()
            logging.info("Drawing resumed by user.")
            if self.pause_resume_button and self.pause_resume_button.winfo_exists():
                self.pause_resume_button.config(text="Pause")
            
            # Add the duration of the pause to the total paused time
            if self.pause_start_time > 0:
                paused_duration = time.time() - self.pause_start_time
                self.total_paused_time += paused_duration
                self.pause_start_time = 0 # Reset for next pause

            # Restart the timer when resumed
            self._update_eta_countdown()

    def update_drawing_status(self, current_command_index, total_commands):
        """Updates the progress bar. The label is handled by the ETA loop."""
        if self.progress_bar and self.progress_bar.winfo_exists():
            self.progress_bar['value'] = current_command_index
        
        # The text variable is now updated entirely by the _update_eta_countdown loop
        # to prevent race conditions and keep the display smooth.

    def request_cancel_drawing(self):
        if self.drawing_in_progress:
            logging.info("Cancel requested by user.")
            self.cancel_requested = True
            self.pause_event.set() # Unblock the drawing loop so it can see the flag
            if self.cancel_button and self.cancel_button.winfo_exists():
                self.cancel_button.config(text="Cancelling...", state=tk.DISABLED)
            if self.pause_resume_button and self.pause_resume_button.winfo_exists():
                self.pause_resume_button.config(state=tk.DISABLED)
            if self.status_label and self.status_label.winfo_exists():
                self.progress_text_var.set("Cancellation requested...")

    def _send_final_position_and_cleanup(self, success_message, failure_message):
        self.drawing_in_progress = False # Stop the ETA loop
        logging.info("Attempting to move robot to final position.")
        # Standardized to (X, Y, Z)
        final_x, final_y, final_z = FINAL_ROBOT_POSITION
        byte_data = struct.pack('!fff', final_x, final_y, final_z)

        move_ok = False
        if self.connected and self.socket:
            if self.send_message_internal(byte_data):
                response_r_final = self.receive_message_internal(timeout=None)
                if response_r_final == "R":
                    response_d_final = self.receive_message_internal(timeout=None)
                    # if response_d_final == "D":
                    #     logging.info("Robot reached final position.")
                    #     move_ok = True
                    # else:
                    #     logging.error(f"Robot didn't confirm final move completion (D), got '{response_d_final}'")
                else:
                    logging.error(f"Robot didn't confirm final move receipt (R), got '{response_r_final}'")
            else:
                logging.error("Failed to send final position command.")

        final_status = ""
        if move_ok:
            final_status = f"{success_message} Robot at final position."
        else:
            final_status = f"{failure_message} Failed to reach final position."

        self.last_drawing_status["status"] = success_message
        self.last_drawing_status["error_message"] = "" if move_ok else "Failed to reach final position."

        self.window.after(0, lambda fs=final_status: self.update_final_status(fs))

        self.selected_commands = None
        self.cancel_requested = False
        if not self.resume_needed:
            self.resume_commands = None
            self.resume_total_original_commands = 0
            self.resume_start_index_global = 0

        self.window.after(2000, self.drawing_options_page)

    def update_final_status(self, message):
        if self.eta_update_id:
            self.window.after_cancel(self.eta_update_id)
            self.eta_update_id = None
        if self.status_label and self.status_label.winfo_exists():
            self.progress_text_var.set(message)
        if self.cancel_button and self.cancel_button.winfo_exists():
            self.cancel_button.pack_forget()
        if self.pause_resume_button and self.pause_resume_button.winfo_exists():
            self.pause_resume_button.pack_forget()

    def run_drawing_loop(self, commands_to_send: List[Tuple], start_index=0):
        """Sends drawing commands one by one using the byte protocol."""
        total_commands = len(commands_to_send)
        
        if start_index > 0:
            self.window.after(0, lambda: self.show_drawing_progress_page(total_commands, start_index))
        
        try:
            # Standardized to (X, Y, Z)
            for i, (x, y, z) in enumerate(commands_to_send[start_index:]):
                self.pause_event.wait()
                if self.cancel_requested:
                    logging.info("Cancellation detected in drawing loop.")
                    # Call the cleanup function to move to a final safe position and reset the UI
                    self._send_final_position_and_cleanup("Drawing Cancelled.", "Drawing Cancelled.")
                    return

                current_command_global_index = start_index + i
                
                # Standardized to pack (X, Y, Z)
                byte_data = struct.pack('!fff', x, y, z)

                if not self.send_message_internal(byte_data):
                    logging.error(f"Connection lost while sending command. Preparing to resume.")
                    self.drawing_in_progress = False # Stop ETA loop
                    self.resume_needed = True
                    self.resume_commands = commands_to_send
                    self.resume_start_index_global = current_command_global_index
                    return

                response_r = self.receive_message_internal(timeout=10.0)
                if response_r != "R":
                    logging.error(f"Robot did not confirm receipt (R), got '{response_r}'.")
                    self.drawing_in_progress = False
                    return
                
                # response_d = self.receive_message_internal(timeout=None)
                # if response_d != "D":
                #     logging.error(f"Robot did not confirm completion (D), got '{response_d}'.")
                #     self.drawing_in_progress = False
                #     return
                
                # Update the progress bar value. The label text is handled by the ETA loop.
                self.window.after(0, lambda p=current_command_global_index + 1: self.update_drawing_status(p, total_commands))

            logging.info("All drawing commands sent successfully.")
            self._send_final_position_and_cleanup("Drawing Complete.", "Drawing Complete.")

        except Exception as e:
            logging.error(f"Unexpected error during drawing process: {e}", exc_info=True)
            self.drawing_in_progress = False

    def send_message_internal(self, message: bytes) -> bool:
        """ Sends byte data without triggering GUI popups on error. Returns success status. """
        if not self.connected or not self.socket: return False
        try:
            self.socket.sendall(message)
            return True
        except (socket.error, ConnectionResetError, BrokenPipeError, socket.timeout) as e:
            logging.error(f"Send error (internal): {e}")
            self.handle_connection_loss()
            return False

    def receive_message_internal(self, timeout=None) -> Optional[str]:
        if not self.connected or not self.socket: return None
        try:
            self.socket.settimeout(timeout)
            data = self.socket.recv(1024)
            self.socket.settimeout(None)
            if not data:
                logging.warning("Receive error (internal): Connection closed by peer.")
                self.handle_connection_loss()
                return None
            decoded_data = data.decode('utf-8').strip()
            return decoded_data
        except socket.timeout:
            logging.error(f"Timeout receiving message (internal)")
            return None
        except (socket.error, ConnectionResetError, BrokenPipeError) as e:
            logging.error(f"Receive error (internal): {e}")
            self.handle_connection_loss()
            return None

    def handle_connection_loss(self):
        logging.warning("Connection lost detected.")
        was_connected = self.connected
        self.close_socket()
        if was_connected and not self.drawing_in_progress and not self.resume_needed:
            self.window.after(0, lambda: messagebox.showinfo("Connection Lost", "Robot connection lost."))

    def establish_connection(self):
        if hasattr(self, 'connect_button') and self.connect_button.winfo_exists(): self.connect_button.config(state=tk.DISABLED)
        if hasattr(self, 'reconnect_button') and self.reconnect_button.winfo_exists(): self.reconnect_button.config(state=tk.DISABLED)

        host, port = (SIMULATION_HOST, SIMULATION_PORT) if self.connection_var.get() == "simulation" else (REAL_ROBOT_HOST, REAL_ROBOT_PORT)

        def connection_attempt():
            try:
                self.close_socket()
                self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                self.socket.settimeout(5)
                self.socket.connect((host, port))
                self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                self.socket.settimeout(None)
                logging.info(f"Connected to {host}:{port}")
                self.connected = True
                self.window.after(0, lambda: self.handle_connection_result(True))
            except (socket.error, socket.timeout, ConnectionRefusedError) as e:
                logging.error(f"Connection error: {e}")
                self.connected = False
                self.close_socket()
                self.window.after(0, lambda: self.handle_connection_result(False))
        threading.Thread(target=connection_attempt, daemon=True).start()

    def handle_connection_result(self, connected):
        if hasattr(self, 'connect_button') and self.connect_button.winfo_exists():
            self.connect_button.config(state=tk.NORMAL)
        if hasattr(self, 'reconnect_button') and self.reconnect_button.winfo_exists():
            self.reconnect_button.config(state=tk.NORMAL)

        if connected:
            self.connection_established = True
            if self.resume_needed and self.resume_commands is not None:
                logging.info("Reconnection successful. Preparing to resume drawing.")
                self.move_to_final_before_resume()
            else:
                self.drawing_options_page()
        else:
            if self.resume_needed:
                messagebox.showerror("Reconnection Failed", "Failed to reconnect. Cannot resume the previous drawing.")
                self.resume_needed = False
                self.resume_commands = None
                self.resume_total_original_commands = 0
                self.resume_start_index_global = 0
                self.last_drawing_status["status"] = "Resume Failed"
                self.last_drawing_status["error_message"] = "Could not reconnect to robot."
                self.drawing_options_page()
            else:
                messagebox.showerror("Connection Failed", "Failed to establish connection.")

    def move_to_final_before_resume(self):
        def move_and_resume_thread():
            logging.info("Moving robot to FINAL_ROBOT_POSITION before resuming...")
            self.show_drawing_progress_page(self.resume_total_original_commands, self.resume_start_index_global)

            # Standardized to (X, Y, Z)
            final_x, final_y, final_z = FINAL_ROBOT_POSITION
            byte_data = struct.pack('!fff', final_x, final_y, final_z)
            move_ok = False
            if self.connected and self.socket:
                if self.send_message_internal(byte_data):
                    response_r = self.receive_message_internal(timeout=5.0)
                    if response_r == "R":
                        response_d = self.receive_message_internal(timeout=5.0)
                        # if response_d == "D":
                        #     logging.info("Robot reached FINAL_ROBOT_POSITION.")
                        #     move_ok = True
                        # else: logging.error("Failed to get 'D' confirmation for pre-resume move.")
                    else: logging.error("Failed to get 'R' confirmation for pre-resume move.")
                else: logging.error("Failed to send pre-resume move command.")

            if move_ok:
                logging.info(f"Starting resume from command index {self.resume_start_index_global}")
                self.drawing_in_progress = True
                self.cancel_requested = False
                self.pause_event.set()
                self.run_drawing_loop(self.resume_commands, self.resume_start_index_global)
            else:
                error_msg = "Failed to move robot to safe resume position."
                logging.error(error_msg + " Cannot resume automatically, but allowing retry.")
                self.last_drawing_status["status"] = "Resume Failed (Pre-move)"
                self.last_drawing_status["error_message"] = error_msg
                self.window.after(0, lambda: messagebox.showwarning("Resume Warning", error_msg + "\nConnection might be unstable. You can try 'Reconnect & Resume' again."))
                self.drawing_in_progress = False
                self.window.after(1000, self.connection_setup_page)

        threading.Thread(target=move_and_resume_thread, daemon=True).start()

    def close_socket(self):
        if self.socket:
            try:
                self.socket.shutdown(socket.SHUT_RDWR)
            except (socket.error, OSError): pass
            finally:
                try: self.socket.close()
                except (socket.error, OSError): pass
                self.socket = None
                logging.info("Socket closed")
        self.connected = False
        self.connection_established = False

    def close_and_return_main(self):
        self.pause_event.set()
        self.close_socket()
        self.resume_needed = False
        self.resume_commands = None
        self.resume_total_original_commands = 0
        self.resume_start_index_global = 0
        self.main_page()

    def clear_frame(self):
        if self.camera_running:
            self.stop_camera_feed()
        # Cancel any pending ETA update
        if self.eta_update_id:
            self.window.after_cancel(self.eta_update_id)
            self.eta_update_id = None
        for widget in self.main_frame.winfo_children():
            widget.destroy()
        self.camera_frame_label = None
        self.capture_button = None
        self.camera_back_button = None
        self.progress_bar = None
        self.status_label = None
        self.cancel_button = None
        self.connect_button = None
        self.reconnect_button = None
        self.preview_label = None
        self.pause_resume_button = None

    def on_window_close(self):
        logging.info("Window close requested.")
        self.cancel_requested = True
        self.drawing_in_progress = False # Stop ETA loop
        self.pause_event.set()
        self.stop_camera_feed()
        self.close_socket()
        time.sleep(0.2)
        self.window.destroy()

if __name__ == "__main__":
    os.makedirs(DATA_DIR, exist_ok=True)
    app = RUNME_GUI()
    app.window.protocol("WM_DELETE_WINDOW", app.on_window_close)
    app.window.mainloop()

--- END OF FILE: testing/main_without_D.py ---
--- START OF FILE: testing/test_main_itworks_A4_GG.py ---
import cv2
import numpy as np
import socket
import time
import math # Import math for distance calculation

# --- Constants ---
A4_WIDTH_MM = 210
A4_HEIGHT_MM = 297
PEN_UP_Z = -10  # Z coordinate for pen up (adjust based on your robot setup)
PEN_DOWN_Z = 0    # Z coordinate for pen down (adjust based on your robot setup)
MIN_CONTOUR_LENGTH_PX = 10 # Ignore very small contours (noise) - adjust as needed

# --- Helper Function ---
def calculate_distance(p1, p2):
    """Calculates Euclidean distance between two points (x, y)."""
    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)

# --- Image Processing Functions ---
def image_to_contours(image_path, output_path, threshold1=25, threshold2=100):
    """
    Convert an image to edges using Canny and find contours.
    :param image_path: Path to the input image.
    :param output_path: Path to save the edge image (optional visual check).
    :param threshold1: Lower threshold for Canny edge detection.
    :param threshold2: Upper threshold for Canny edge detection.
    :return: List of contours (each a list of pixel coordinates), image dimensions (width, height).
    """
    image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)
    if image is None:
        raise FileNotFoundError(f"Could not read image from {image_path}")

    image_height, image_width = image.shape[:2] # Get image dimensions

    blurred = cv2.GaussianBlur(image, (5, 5), 0)
    edges = cv2.Canny(blurred, threshold1, threshold2)
    cv2.imwrite(output_path, edges) # Save the edges image for verification

    # Find contours - Use RETR_LIST to get all contours, CHAIN_APPROX_SIMPLE to compress segments
    contours, hierarchy = cv2.findContours(edges, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)

    # Filter out very small contours (likely noise)
    filtered_contours = [c for c in contours if cv2.arcLength(c, closed=False) > MIN_CONTOUR_LENGTH_PX]

    print(f"Found {len(contours)} raw contours, {len(filtered_contours)} contours after filtering.")

    # Reshape contours to be lists of (x, y) tuples
    contours_xy = []
    for contour in filtered_contours:
        # Squeeze removes single-dimensional entries from the shape of an array.
        # Contours from findContours are often [[[x1, y1]], [[x2, y2]], ...]
        points = contour.squeeze().tolist()
        # Handle cases where squeeze might result in a single point (not a list)
        if isinstance(points[0], int):
             points = [points] # Make it a list containing the single point tuple
        contours_xy.append([(p[0], p[1]) for p in points])


    return contours_xy, image_width, image_height

def scale_point_to_a4(point_xy, image_width, image_height, scale_factor):
    """
    Scales and transforms a single (x, y) pixel coordinate to centered A4 (mm).
    :param point_xy: Tuple (x, y) pixel coordinate.
    :param image_width: Width of the original image in pixels.
    :param image_height: Height of the original image in pixels.
    :param scale_factor: Pre-calculated scale factor for A4 fitting.
    :return: Tuple (x_mm, y_mm) scaled coordinate.
    """
    x_pixel, y_pixel = point_xy
    center_x_pixel = image_width / 2
    center_y_pixel = image_height / 2

    # Translate pixel coordinates so (0,0) is the image center
    x_centered_pixel = x_pixel - center_x_pixel
    # Invert y-axis (image y increases downwards, cartesian y increases upwards)
    y_centered_pixel = center_y_pixel - y_pixel

    # Scale the centered coordinates to millimeters
    x_mm = x_centered_pixel * scale_factor
    y_mm = y_centered_pixel * scale_factor

    return (x_mm, y_mm)

def create_drawing_paths(contours_xy, image_width, image_height, optimize_paths=True):
    """
    Takes list of contours (pixel coordinates), scales them, and creates drawing paths.
    Each path is a sequence of (X, Z, Y) commands for the robot.
    :param contours_xy: List of contours, where each contour is a list of (x, y) pixel points.
    :param image_width: Width of the original image.
    :param image_height: Height of the original image.
    :param optimize_paths: Boolean flag to enable path optimization (nearest neighbor).
    :return: List of robot commands [(X, Z, Y), ...].
    """
    # Calculate the single scale factor for the entire drawing
    scale_x = A4_WIDTH_MM / image_width
    scale_y = A4_HEIGHT_MM / image_height
    scale_factor = min(scale_x, scale_y)

    scaled_contours = []
    for contour in contours_xy:
        scaled_contour = [scale_point_to_a4(p, image_width, image_height, scale_factor) for p in contour]
        if len(scaled_contour) >= 2: # Need at least two points to form a line
             scaled_contours.append(scaled_contour)

    if not scaled_contours:
        return []

    # --- Path Optimization (Optional but Recommended) ---
    # Order the contours to minimize travel distance between the end of one contour
    # and the start of the next (Nearest Neighbor approach).
    ordered_contours = []
    if optimize_paths and scaled_contours:
        remaining_contours = list(scaled_contours) # Make a copy
        # Start with the first contour (arbitrary, could pick longest/closest to origin etc.)
        current_contour = remaining_contours.pop(0)
        ordered_contours.append(current_contour)
        last_point = current_contour[-1] # End point of the current contour

        while remaining_contours:
            best_dist = float('inf')
            best_idx = -1
            best_reversed = False # Should we draw the next contour in reverse?

            for i, contour in enumerate(remaining_contours):
                start_point = contour[0]
                end_point = contour[-1]

                # Distance from last_point to start of this contour
                dist_start = calculate_distance(last_point, start_point)
                # Distance from last_point to end of this contour (if drawn in reverse)
                dist_end = calculate_distance(last_point, end_point)

                if dist_start < best_dist:
                    best_dist = dist_start
                    best_idx = i
                    best_reversed = False

                if dist_end < best_dist:
                    best_dist = dist_end
                    best_idx = i
                    best_reversed = True

            # Select the best next contour
            next_contour = remaining_contours.pop(best_idx)
            if best_reversed:
                next_contour.reverse() # Reverse it in place

            ordered_contours.append(next_contour)
            last_point = next_contour[-1] # Update last point for next iteration

        scaled_contours = ordered_contours # Use the optimized order
        print(f"Optimized contour drawing order.")

    # --- Generate Robot Commands ---
    robot_commands = []
    for contour in scaled_contours:
        start_point = contour[0]
        # 1. Move to the start of the contour (Pen Up)
        robot_commands.append((start_point[0], PEN_UP_Z, start_point[1]))
        # 2. Put Pen Down at the start
        robot_commands.append((start_point[0], PEN_DOWN_Z, start_point[1]))

        # 3. Draw along the contour segments (Pen Down)
        for i in range(len(contour) - 1):
            end_point = contour[i+1]
            # Only add command if it's different from the previous (handles single points)
            if end_point != contour[i]:
                 robot_commands.append((end_point[0], PEN_DOWN_Z, end_point[1]))

        # 4. Lift Pen at the end of the contour
        final_point = contour[-1]
        robot_commands.append((final_point[0], PEN_UP_Z, final_point[1]))

    return robot_commands


# --- Socket Communication Functions ---
# (connect_to_robot, send_message, receive_message remain the same)
def connect_to_robot(host, port):
    """ Connect to the robot controller and return the socket object. """
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(10)
        s.connect((host, port))
        print(f"Connected to the robot controller at {host}:{port}")
        return s
    except socket.timeout:
        print("Socket timeout during connection")
        return None
    except socket.error as e:
        print(f"Socket error during connection: {e}")
        return None

def send_message(s, message):
    """ Send a message to the robot controller. """
    try:
        s.sendall(message.encode('utf-8'))
        # print(f"Sent: {message}") # Reduce verbosity
        return True
    except socket.timeout:
        print("Socket timeout during send")
        return False
    except socket.error as e:
        print(f"Send error: {e}")
        return False

def receive_message(s, buffer_size=1024):
    """ Receive a message from the robot controller. """
    try:
        data = s.recv(buffer_size)
        decoded_data = data.decode('utf-8').strip()
        # print(f"Received: {decoded_data}") # Reduce verbosity
        return decoded_data
    except socket.timeout:
        print("Socket timeout during receive")
        return None
    except socket.error as e:
        print(f"Receive error: {e}")
        return None

# --- Function to dump point data into a text file ---
def dump_path_data(robot_commands, file_path):
    """
    Dump the robot command path data into a text file.
    Format: X, Z, Y
    :param robot_commands: List of robot commands [(X, Z, Y), ...].
    :param file_path: Path to save the point data file.
    """
    with open(file_path, 'w') as file:
        for (x, z, y) in robot_commands:
            file.write(f"{x:.2f}, {z}, {y:.2f}\n")


# --- Main Function ---
def main():
    input_image_path = "C:/Users/USER/Learn_Coding/TROB1_drawing_with_voice_command/image2.jpg"
    output_edge_path = "C:/Users/USER/Learn_Coding/TROB1_drawing_with_voice_command/line_art_edges_output.jpg"
    output_path_data_path = "C:/Users/USER/Learn_Coding/TROB1_drawing_with_voice_command/path_data_a4_optimized.txt"

    HOST = '127.0.0.1'
    PORT = 55000

    try:
        # Step 1: Find contours from the image
        contours_xy, image_width, image_height = image_to_contours(input_image_path, output_edge_path)

        if not contours_xy:
            print("No contours found or remaining after filtering.")
            return

        # Step 2: Create scaled drawing paths from contours
        # optimize_paths=True will try to draw contours in an efficient order
        robot_commands = create_drawing_paths(contours_xy, image_width, image_height, optimize_paths=True)
        print(f"Generated {len(robot_commands)} robot commands.")

        if not robot_commands:
             print("No robot commands generated.")
             return

        # Step 3: Dump the command path data to a file
        dump_path_data(robot_commands, output_path_data_path)
        print(f"Optimized path data saved to {output_path_data_path}")

        # Step 4: Socket communication
        user_input = input("Enter '1' to connect to the robot and send drawing instructions: ")
        if user_input == '1':
            robot_socket = connect_to_robot(HOST, PORT)
            if robot_socket is None:
                print("Failed to connect.")
                return

            try:
                total_commands = len(robot_commands)
                for i, (x, z, y) in enumerate(robot_commands):
                    command_str = f"{x:.2f},{z},{y:.2f}"
                    print(f"Sending command {i+1}/{total_commands}: {command_str} ", end="")

                    if not send_message(robot_socket, command_str):
                        print(" Send failed.")
                        break

                    # Wait for receipt (R)
                    response_r = receive_message(robot_socket)
                    if response_r != "R":
                        print(f" Robot did not confirm receipt (R), got '{response_r}'. Stopping.")
                        break
                    print("[R] ", end="")

                    # Wait for completion (D)
                    response_d = receive_message(robot_socket)
                    if response_d != "D":
                        print(f" Robot did not confirm completion (D), got '{response_d}'. Stopping.")
                        break
                    print("[D]")

                    # Optional short delay
                    # time.sleep(0.05)

                print("\n--- Drawing sequence finished or stopped ---")

            except Exception as e:
                print(f"\nAn error occurred during robot communication: {e}")
            finally:
                robot_socket.close()
                print("Connection closed")
        else:
            print("Connection aborted by user.")

    except FileNotFoundError as e:
        print(f"Error: {e}")
    except Exception as e:
        print(f"An unexpected error occurred: {e}")

if __name__ == "__main__":
    main()
--- END OF FILE: testing/test_main_itworks_A4_GG.py ---
--- START OF FILE: testing/rapid_code_no_D.mod ---
MODULE AUTO_InputDrawing
    ! Socket and other declarations
    VAR socketdev client_socket;
    VAR socketdev temp_socket;
    
    ! Constant Targets
    CONST robtarget home1:=[[409.328464947,30.699294352,-350.922061873],[0.999898286,-0.005230998,0.00469865,0.012408784],[0,-1,1,0],[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]];
    CONST robtarget WorkSpaceCenter1:=[[75.78,312.76,9.799641871],[0.988089954,-0.00592235,0.00373461,-0.153717993],[0,0,0,0],[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]];
    CONST robtarget Pre_pack := [[121.48,454.11,-217.7],[0.750819,-0.242807,0.193622,0.582946],[0,-1,1,0],[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]];
    TASK PERS wobjdata Wobj_1:=[FALSE,TRUE,"",[[87.974520519,-126.434467699,0],[0,0.707106781,0.707106781,0]],[[0,0,0],[1,0,0,0]]];

    ! Main robot routine
    PROC main()
        ! Local variables for the coordinates
        VAR num x_val;
        VAR num y_val;
        VAR num z_val;
        VAR rawbytes received_bytes;
        VAR num read_pos;

        MoveJ home1,v1000,z100,tool2\WObj:=Wobj_1;
        SocketConnect;

        WHILE TRUE DO
            ! Reset read position for each new message
            read_pos := 1;
            
            ! Receive exactly 12 raw bytes from the client
            SocketReceive client_socket\RawData:=received_bytes, \ReadNoOfBytes:=12, \Time:=WAIT_MAX;
            
            ! Send "Ready" confirmation (1 byte)
            SocketSend client_socket\Str:="R" \NoOfBytes:=1;
            
            ! Unpack X from the starting position
            UnpackRawBytes received_bytes\Network, read_pos, x_val\Float4;
            ! Manually advance the read position by 4 bytes (the size of a Float4)
            read_pos := read_pos + 4;

            ! Unpack Y from the new position
            UnpackRawBytes received_bytes\Network, read_pos, y_val\Float4;
            ! Manually advance the read position by 4 bytes
            read_pos := read_pos + 4;

            ! Unpack Z from the final position
            UnpackRawBytes received_bytes\Network, read_pos, z_val\Float4;

            ! Optional: You can keep these for debugging on the Teach Pendant
            TPWrite "Received X:" \Num:= x_val;
            TPWrite "Received Y:" \Num:= y_val;
            TPWrite "Received Z:" \Num:= z_val;

            ! Perform the move using the standardized (X, Y, Z) offsets
            MoveL Offs(WorkSpaceCenter1, x_val, -y_val, z_val), vmax, z100, tool2\WObj:=Wobj_1;
            
            ! Send "Done" confirmation (1 byte)
            SocketSend client_socket\Str:="D" \NoOfBytes:=1;
        ENDWHILE
    ENDPROC

    ! Use the appropriate connection procedure for your setup
    PROC SocketConnect()
        SocketCreate temp_socket;
        SocketBind temp_socket,"127.0.0.1",55000;
        SocketListen temp_socket;
        SocketAccept temp_socket,client_socket,\Time:=WAIT_MAX;
        TPWrite "Socket connection established.";
    ENDPROC
    
    ! For Real Robot:
    ! PROC SocketConnect()
    !     SocketCreate temp_socket;
    !     SocketBind temp_socket,"192.168.125.1",1025;
    !     SocketListen temp_socket;
    !     SocketAccept temp_socket,client_socket,\Time:=WAIT_MAX;
    !     TPWrite "Socket connection established.";
    ! ENDPROC

ENDMODULE

--- END OF FILE: testing/rapid_code_no_D.mod ---
--- START OF FILE: testing/rapid_code.mod ---
MODULE AUTO_InputDrawing
    ! Socket and other declarations
    VAR socketdev client_socket;
    VAR socketdev temp_socket;
    
    ! Constant Targets
    CONST robtarget home1:=[[409.328464947,30.699294352,-350.922061873],[0.999898286,-0.005230998,0.00469865,0.012408784],[0,-1,1,0],[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]];
    CONST robtarget WorkSpaceCenter1:=[[75.78,312.76,9.799641871],[0.988089954,-0.00592235,0.00373461,-0.153717993],[0,0,0,0],[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]];
    CONST robtarget Pre_pack := [[121.48,454.11,-217.7],[0.750819,-0.242807,0.193622,0.582946],[0,-1,1,0],[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]];
    TASK PERS wobjdata Wobj_1:=[FALSE,TRUE,"",[[87.974520519,-126.434467699,0],[0,0.707106781,0.707106781,0]],[[0,0,0],[1,0,0,0]]];

    ! Main robot routine
    PROC main()
        ! Local variables for the coordinates
        VAR num x_val;
        VAR num y_val;
        VAR num z_val;
        VAR rawbytes received_bytes;
        VAR num read_pos;

        MoveJ home1,v1000,z100,tool2\WObj:=Wobj_1;
        SocketConnect;

        WHILE TRUE DO
            ! Reset read position for each new message
            read_pos := 1;
            
            ! Receive exactly 12 raw bytes from the client
            SocketReceive client_socket\RawData:=received_bytes, \ReadNoOfBytes:=12, \Time:=WAIT_MAX;
            
            ! Send "Ready" confirmation (1 byte)
            SocketSend client_socket\Str:="R" \NoOfBytes:=1;
            
            ! Unpack X from the starting position
            UnpackRawBytes received_bytes\Network, read_pos, x_val\Float4;
            ! Manually advance the read position by 4 bytes (the size of a Float4)
            read_pos := read_pos + 4;

            ! Unpack Y from the new position
            UnpackRawBytes received_bytes\Network, read_pos, y_val\Float4;
            ! Manually advance the read position by 4 bytes
            read_pos := read_pos + 4;

            ! Unpack Z from the final position
            UnpackRawBytes received_bytes\Network, read_pos, z_val\Float4;

            ! Optional: You can keep these for debugging on the Teach Pendant
            TPWrite "Received X:" \Num:= x_val;
            TPWrite "Received Y:" \Num:= y_val;
            TPWrite "Received Z:" \Num:= z_val;

            ! Perform the move using the standardized (X, Y, Z) offsets
            MoveL Offs(WorkSpaceCenter1, x_val, -y_val, z_val), vmax, z100, tool2\WObj:=Wobj_1;
            
            ! Send "Done" confirmation (1 byte)
            SocketSend client_socket\Str:="D" \NoOfBytes:=1;
        ENDWHILE
    ENDPROC

    ! Use the appropriate connection procedure for your setup
    PROC SocketConnect()
        SocketCreate temp_socket;
        SocketBind temp_socket,"127.0.0.1",55000;
        SocketListen temp_socket;
        SocketAccept temp_socket,client_socket,\Time:=WAIT_MAX;
        TPWrite "Socket connection established.";
    ENDPROC
    
    ! For Real Robot:
    ! PROC SocketConnect()
    !     SocketCreate temp_socket;
    !     SocketBind temp_socket,"192.168.125.1",1025;
    !     SocketListen temp_socket;
    !     SocketAccept temp_socket,client_socket,\Time:=WAIT_MAX;
    !     TPWrite "Socket connection established.";
    ! ENDPROC

ENDMODULE

--- END OF FILE: testing/rapid_code.mod ---
--- START OF FILE: testing/rapid_code_no_R.mod ---
MODULE AUTO_InputDrawing
    ! Socket and other declarations
    VAR socketdev client_socket;
    VAR socketdev temp_socket;
    
    ! Constant Targets
    CONST robtarget home1:=[[409.328464947,30.699294352,-350.922061873],[0.999898286,-0.005230998,0.00469865,0.012408784],[0,-1,1,0],[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]];
    CONST robtarget WorkSpaceCenter1:=[[75.78,312.76,9.799641871],[0.988089954,-0.00592235,0.00373461,-0.153717993],[0,0,0,0],[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]];
    CONST robtarget Pre_pack := [[121.48,454.11,-217.7],[0.750819,-0.242807,0.193622,0.582946],[0,-1,1,0],[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]];
    TASK PERS wobjdata Wobj_1:=[FALSE,TRUE,"",[[87.974520519,-126.434467699,0],[0,0.707106781,0.707106781,0]],[[0,0,0],[1,0,0,0]]];

    ! Main robot routine
    PROC main()
        ! Local variables for the coordinates
        VAR num x_val;
        VAR num y_val;
        VAR num z_val;
        VAR rawbytes received_bytes;
        VAR num read_pos;

        MoveJ home1,v1000,z100,tool2\WObj:=Wobj_1;
        SocketConnect;

        WHILE TRUE DO
            ! Reset read position for each new message
            read_pos := 1;
            
            ! Receive exactly 12 raw bytes from the client
            SocketReceive client_socket\RawData:=received_bytes, \ReadNoOfBytes:=12, \Time:=WAIT_MAX;
            
            ! ! Send "Ready" confirmation (1 byte)
            ! SocketSend client_socket\Str:="R" \NoOfBytes:=1;
            
            ! Unpack X from the starting position
            UnpackRawBytes received_bytes\Network, read_pos, x_val\Float4;
            ! Manually advance the read position by 4 bytes (the size of a Float4)
            read_pos := read_pos + 4;

            ! Unpack Y from the new position
            UnpackRawBytes received_bytes\Network, read_pos, y_val\Float4;
            ! Manually advance the read position by 4 bytes
            read_pos := read_pos + 4;

            ! Unpack Z from the final position
            UnpackRawBytes received_bytes\Network, read_pos, z_val\Float4;

            ! Optional: You can keep these for debugging on the Teach Pendant
            TPWrite "Received X:" \Num:= x_val;
            TPWrite "Received Y:" \Num:= y_val;
            TPWrite "Received Z:" \Num:= z_val;

            ! Perform the move using the standardized (X, Y, Z) offsets
            MoveL Offs(WorkSpaceCenter1, x_val, -y_val, z_val), vmax, z100, tool2\WObj:=Wobj_1;
            
            ! Send "Done" confirmation (1 byte)
            SocketSend client_socket\Str:="D" \NoOfBytes:=1;
        ENDWHILE
    ENDPROC

    ! Use the appropriate connection procedure for your setup
    PROC SocketConnect()
        SocketCreate temp_socket;
        SocketBind temp_socket,"127.0.0.1",55000;
        SocketListen temp_socket;
        SocketAccept temp_socket,client_socket,\Time:=WAIT_MAX;
        TPWrite "Socket connection established.";
    ENDPROC
    
    ! For Real Robot:
    ! PROC SocketConnect()
    !     SocketCreate temp_socket;
    !     SocketBind temp_socket,"192.168.125.1",1025;
    !     SocketListen temp_socket;
    !     SocketAccept temp_socket,client_socket,\Time:=WAIT_MAX;
    !     TPWrite "Socket connection established.";
    ! ENDPROC

ENDMODULE

--- END OF FILE: testing/rapid_code_no_R.mod ---
--- START OF FILE: testing/main.py ---
# testing/main.py
import tkinter as tk
from tkinter import messagebox, filedialog, ttk
import os
import threading
import time
import logging
import socket
import struct # Import the struct module for packing data
from concurrent.futures import ThreadPoolExecutor
from typing import List, Tuple, Optional
import cv2
import numpy as np
import math
from PIL import Image, ImageTk

# Configure logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")

# --- Constants (Consolidated) ---
SCRIPT_DIR = os.getenv("SCRIPT_DIR", ".")
DATA_DIR = os.getenv("DATA_DIR", ".")

TMP_CAPTURE_PATH = os.path.join(DATA_DIR, "temp_capture.png")
TMP_EDGE_OUTPUT_PATH = os.path.join(DATA_DIR, "temp_edges_{}.png")

REAL_ROBOT_HOST = '192.168.125.1'
REAL_ROBOT_PORT = 1025
SIMULATION_HOST = '127.0.0.1'
SIMULATION_PORT = 55000

# Drawing Specific Constants
# Standardized to (X, Y, Z)
FINAL_ROBOT_POSITION = (0, 0, -350)
A4_WIDTH_MM = 180
A4_HEIGHT_MM = 217
# This is now a DEFAULT value, which can be overridden by the GUI.
PEN_DOWN_Z = -14 
PEN_UP_Z = 1.3 * PEN_DOWN_Z 
MIN_CONTOUR_LENGTH_PX = 10

# Threshold options
THRESHOLD_OPTIONS = [
    ("Option {}".format(i), i*10, i*20) for i in range(1, 8)
]

# Time estimation factor
TIME_ESTIMATE_FACTOR = 0.018

# Waypoints for the signature drawing, using specific Z-depths.
SIGNATURE_WAYPOINTS = ((0, 0, -70),)


def create_signature_commands(waypoints, pen_down_z):
    """Converts signature waypoints into robot commands, handling pen up/down moves."""
    pen_up_z = 1.3 * pen_down_z
    if pen_up_z == 0:
        pen_up_z = -3
    commands = []
    if not waypoints:
        return commands

    # Move to the starting XY of the signature with the pen up
    start_x, start_y, _ = waypoints[0]
    commands.append((start_x, start_y, pen_up_z))

    # Add the actual drawing waypoints
    for point in waypoints:
        commands.append(point)

    # Lift the pen at the end of the signature
    if commands:
        last_x, last_y, _ = waypoints[-1]
        commands.append((last_x, last_y, pen_up_z))
    return commands


def calculate_distance(p1, p2):
    """Calculates Euclidean distance between two points (x, y)."""
    if p1 is None or p2 is None: return float('inf')
    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)


def image_to_contours_internal(image_path_or_array, threshold1, threshold2, save_edge_path=None):
    if isinstance(image_path_or_array, str):
        image = cv2.imread(image_path_or_array, cv2.IMREAD_GRAYSCALE)
    elif isinstance(image_path_or_array, np.ndarray):
        if len(image_path_or_array.shape) == 3:
            image = cv2.cvtColor(image_path_or_array, cv2.COLOR_BGR2GRAY)
        else:
            image = image_path_or_array
    else:
        logging.error("Invalid input type for image_to_contours_internal")
        return None, 0, 0

    if image is None:
        logging.error(f"Could not read or process image input.")
        return None, 0, 0

    image_height, image_width = image.shape[:2]
    if image_height == 0 or image_width == 0:
        logging.error("Invalid image dimensions.")
        return None, 0, 0

    blurred = cv2.GaussianBlur(image, (5, 5), 0)
    edges = cv2.Canny(blurred, threshold1, threshold2)

    if save_edge_path:
        try:
            cv2.imwrite(save_edge_path, edges)
        except Exception as e:
            logging.error(f"Failed to save edge image to {save_edge_path}: {e}")

    contours, _ = cv2.findContours(edges, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)
    filtered_contours = [c for c in contours if cv2.arcLength(c, closed=False) > MIN_CONTOUR_LENGTH_PX]

    contours_xy = []
    for contour in filtered_contours:
        points = contour.squeeze().tolist()
        if not isinstance(points, list) or not points: continue
        if isinstance(points[0], int):
            points = [points]
        contours_xy.append([(p[0], p[1]) for p in points if isinstance(p, (list, tuple)) and len(p) == 2])

    contours_xy = [c for c in contours_xy if c]
    return contours_xy, image_width, image_height


def scale_point_to_a4(point_xy, image_width, image_height, scale_factor):
    x_pixel, y_pixel = point_xy
    center_x_pixel = image_width / 2
    center_y_pixel = image_height / 2
    x_centered_pixel = x_pixel - center_x_pixel
    y_centered_pixel = center_y_pixel - y_pixel
    x_mm = x_centered_pixel * scale_factor
    y_mm = y_centered_pixel * scale_factor
    return (x_mm, y_mm)


def create_drawing_paths(contours_xy, image_width, image_height, pen_down_z, optimize_paths=True):
    """Generates robot drawing paths using a specific Z-height for pen-down moves."""
    if not contours_xy or image_width <= 0 or image_height <= 0:
        return []

    pen_up_z = 1.3 * pen_down_z
    if pen_up_z == 0:
        pen_up_z = -3

    scale_x = A4_WIDTH_MM / image_width
    scale_y = A4_HEIGHT_MM / image_height
    scale_factor = min(scale_x, scale_y)

    scaled_contours = []
    for contour in contours_xy:
        if not contour: continue
        scaled_contour = [scale_point_to_a4(p, image_width, image_height, scale_factor) for p in contour]
        if len(scaled_contour) >= 2:
            scaled_contours.append(scaled_contour)
        elif len(scaled_contour) == 1:
            scaled_contours.append([scaled_contour[0], scaled_contour[0]])

    if not scaled_contours:
        return []

    ordered_contours = []
    last_point = None
    if optimize_paths:
        remaining_contours = list(scaled_contours)
        if remaining_contours:
            current_contour = remaining_contours.pop(0)
            ordered_contours.append(current_contour)
            last_point = current_contour[-1]

            while remaining_contours:
                best_dist = float('inf')
                best_idx = -1
                best_reversed = False

                for i, contour in enumerate(remaining_contours):
                    start_point = contour[0]
                    end_point = contour[-1]
                    dist_start = calculate_distance(last_point, start_point)
                    dist_end = calculate_distance(last_point, end_point)

                    if dist_start < best_dist:
                        best_dist = dist_start
                        best_idx = i
                        best_reversed = False
                    if dist_end < best_dist:
                        best_dist = dist_end
                        best_idx = i
                        best_reversed = True

                if best_idx != -1:
                    next_contour = remaining_contours.pop(best_idx)
                    if best_reversed:
                        next_contour.reverse()
                    ordered_contours.append(next_contour)
                    last_point = next_contour[-1]
                else:
                    logging.warning("Path optimization loop finished unexpectedly.")
                    break
        scaled_contours = ordered_contours
    else:
        scaled_contours = [c for c in scaled_contours]

    robot_commands = []
    for contour in scaled_contours:
        if not contour: continue
        start_point = contour[0]
        # Standardized to (X, Y, Z)
        robot_commands.append((start_point[0], start_point[1], pen_up_z))
        robot_commands.append((start_point[0], start_point[1], pen_down_z))

        for i in range(len(contour) - 1):
            end_point = contour[i+1]
            if end_point != contour[i]:
                # Standardized to (X, Y, Z)
                robot_commands.append((end_point[0], end_point[1], pen_down_z))

        final_point = contour[-1]
        # Standardized to (X, Y, Z)
        robot_commands.append((final_point[0], final_point[1], pen_up_z))

    return robot_commands


class RUNME_GUI:
    """Main GUI application for the Robotics System."""

    def __init__(self):
        self.window = tk.Tk()
        self.window.title("Robotics Drawing GUI")
        self.main_frame = tk.Frame(self.window)
        self.main_frame.pack(pady=20, padx=20, fill="both", expand=True)

        self.connection_var = tk.StringVar(value="simulation")
        self.socket = None
        self.connected = False
        self.connection_established = False

        self.cap = None
        self.camera_running = False
        self.camera_frame_label = None
        self.capture_button = None
        self.camera_back_button = None

        self.current_image_path = None
        self.threshold_options_data = {}
        self.selected_commands = None
        self.drawing_in_progress = False
        self.cancel_requested = False
        self.progress_bar = None
        self.status_label = None
        self.cancel_button = None
        self.reconnect_button = None
        
        self.test_z_var = tk.StringVar(value=str(PEN_DOWN_Z))
        
        self.pause_event = threading.Event()
        self.pause_resume_button = None

        self.last_drawing_status = {
            "total_commands": 0,
            "completed_commands": 0,
            "status": "None",
            "error_message": ""
        }
        
        self.resume_needed = False
        self.resume_commands = None
        self.resume_total_original_commands = 0
        self.resume_start_index_global = 0

        # --- ETA Countdown variables ---
        self.eta_update_id = None
        self.drawing_start_time = 0
        self.total_paused_time = 0
        self.pause_start_time = 0
        self.progress_text_var = tk.StringVar()


        self.main_page()

    def main_page(self):
        self.clear_frame()
        tk.Label(self.main_frame, text="Robotics Drawing System", font=("Arial", 16)).pack(pady=10)
        tk.Button(self.main_frame, text="Setup Connection & Draw",
                  command=self.connection_setup_page, width=30).pack(pady=5)
        tk.Button(self.main_frame, text="Exit",
                  command=self.on_window_close, width=30).pack(pady=5)

    def connection_setup_page(self):
        self.clear_frame()
        tk.Label(self.main_frame, text="Robot Connection Setup", font=("Arial", 16)).pack(pady=10)

        connection_frame = tk.Frame(self.main_frame)
        connection_frame.pack(pady=10)
        tk.Radiobutton(connection_frame, text=f"Simulation: {SIMULATION_HOST}:{SIMULATION_PORT}",
                       variable=self.connection_var, value="simulation").pack(anchor='w')
        tk.Radiobutton(connection_frame, text=f"Real Robot: {REAL_ROBOT_HOST}:{REAL_ROBOT_PORT}",
                       variable=self.connection_var, value="real").pack(anchor='w')

        self.connect_button = tk.Button(self.main_frame, text="Connect", command=self.establish_connection, width=20)
        self.reconnect_button = tk.Button(self.main_frame, text="Reconnect & Resume", command=self.establish_connection, width=20)

        if self.resume_needed:
            self.reconnect_button.pack(pady=5)
            tk.Label(self.main_frame, text="Connection lost during last drawing. Reconnect to resume.", fg="orange").pack()
        else:
            self.connect_button.pack(pady=5)

        tk.Button(self.main_frame, text="Back", command=self.main_page, width=20).pack(pady=5)

    def drawing_options_page(self):
        if not self.connection_established:
            messagebox.showerror("Connection Required", "Please establish connection first.")
            self.connection_setup_page()
            return

        self.clear_frame()
        tk.Label(self.main_frame, text="Robot Drawing Options", font=("Arial", 16)).pack(pady=10)
        conn_type = "Simulation" if self.connection_var.get() == "simulation" else "Real Robot"
        tk.Label(self.main_frame, text=f"Connected to: {conn_type}", fg="green").pack(pady=5)
        last_status = self.last_drawing_status["status"]
        if last_status not in ["None", "Completed"]:
            status_frame = tk.Frame(self.main_frame, relief=tk.RIDGE, borderwidth=2)
            status_frame.pack(pady=10, padx=10, fill='x')
            tk.Label(status_frame, text="Previous Drawing Status:", font=("Arial", 10, "bold")).pack(anchor='w')
            status_text = f"Status: {last_status}"
            if self.last_drawing_status["total_commands"] > 0:
                status_text += f" (Stopped at command {self.last_drawing_status['completed_commands'] + 1}" \
                               f" of {self.last_drawing_status['total_commands']})"
            tk.Label(status_frame, text=status_text).pack(anchor='w', padx=5)
            if self.last_drawing_status["error_message"]:
                tk.Label(status_frame, text=f"Details: {self.last_drawing_status['error_message']}", wraplength=400).pack(anchor='w', padx=5)

        test_z_frame = tk.Frame(self.main_frame, pady=5)
        test_z_frame.pack(pady=5)

        tk.Label(test_z_frame, text="Test / Drawing Z-Coordinate:").pack(side=tk.LEFT, padx=5)
        test_z_entry = tk.Entry(test_z_frame, textvariable=self.test_z_var, width=10)
        test_z_entry.pack(side=tk.LEFT)
        
        self.send_z_button = tk.Button(test_z_frame, text="Send to (0, 0, Z)", command=self.send_to_test_z_action)
        self.send_z_button.pack(side=tk.LEFT, padx=10)

        test_buttons_frame = tk.Frame(self.main_frame)
        test_buttons_frame.pack(pady=5)

        self.safe_center_button = tk.Button(test_buttons_frame, text="Go to Safe Center", command=self.send_to_safe_center_action, width=20)
        self.safe_center_button.pack(side=tk.LEFT, padx=5)

        self.test_workspace_button = tk.Button(test_buttons_frame, text="Test Workspace", command=self.test_workspace_action, width=20)
        self.test_workspace_button.pack(side=tk.LEFT, padx=5)

        tk.Button(self.main_frame, text="Capture Image to Draw",
                  command=self.capture_image_page, width=30).pack(pady=5)
        tk.Button(self.main_frame, text="Input Image to Draw",
                  command=self.input_image_page, width=30).pack(pady=5)
        
        tk.Button(self.main_frame, text="Disconnect",
                  command=self.close_and_return_main, width=30).pack(pady=5)

    def send_to_test_z_action(self):
        try:
            test_z = float(self.test_z_var.get())
        except ValueError:
            messagebox.showerror("Invalid Input", "The Z-coordinate must be a valid number.")
            return

        if self.send_z_button and self.send_z_button.winfo_exists():
            self.send_z_button.config(state=tk.DISABLED)
        # Standardized to (X, Y, Z)
        threading.Thread(target=self._send_command_sequence_thread, args=([(0.0, 0.0, test_z)], self.send_z_button), daemon=True).start()

    def send_to_safe_center_action(self):
        safe_z = 6 * PEN_DOWN_Z
        
        if hasattr(self, 'safe_center_button') and self.safe_center_button.winfo_exists():
            self.safe_center_button.config(state=tk.DISABLED)
        
        # Standardized to (X, Y, Z)
        logging.info(f"Sending robot to safe center (0, 0, {safe_z})")
        threading.Thread(target=self._send_command_sequence_thread, args=([(0, 0, safe_z)], self.safe_center_button), daemon=True).start()

    def test_workspace_action(self):
        """Sends the robot on a path to outline the workspace corners."""
        try:
            test_z = float(self.test_z_var.get())
        except ValueError:
            messagebox.showerror("Invalid Input", "The Z-coordinate for testing must be a valid number.")
            return

        if hasattr(self, 'test_workspace_button') and self.test_workspace_button.winfo_exists():
            self.test_workspace_button.config(state=tk.DISABLED)

        pen_up_z = 1.3 * test_z
        
        if pen_up_z == 0:
            pen_up_z = -3

        # Standardized to (X, Y, Z)
        workspace_path = [
            (0,0, test_z),
            (50, 50, test_z),
            (50, -50, test_z),
            (-50, -50, test_z),
            (-50, 50, test_z),
            (0,0, test_z),
            (0, 0, pen_up_z)
        ]
        
        logging.info("Starting workspace test...")
        
        threading.Thread(target=self._send_command_sequence_thread, args=(workspace_path, self.test_workspace_button), daemon=True).start()

    def _send_command_sequence_thread(self, commands: List[Tuple], button_to_re_enable: tk.Button):
        """Thread worker to send a sequence of commands, one by one, using the new byte protocol."""
        original_text = button_to_re_enable.cget("text")
        self.window.after(0, lambda: button_to_re_enable.config(text="Moving..."))

        # Standardized to (X, Y, Z)
        for i, (x, y, z) in enumerate(commands):
            if self.cancel_requested:
                logging.info("Test sequence cancelled.")
                break
            
            logging.info(f"Sending command {i+1}/{len(commands)}: ({x:.2f}, {y:.2f}, {z:.2f})")
            # Standardized to pack (X, Y, Z)
            byte_data = struct.pack('!fff', x, y, z)
            
            if self.send_message_internal(byte_data):
                response_r = self.receive_message_internal(timeout=5.0)
                if response_r == "R":
                    logging.info("Received 'R' (Ready) from robot.")
                    response_d = self.receive_message_internal(timeout=None)
                    if response_d == "D":
                        logging.info("Received 'D' (Done) from robot.")
                    else:
                        error_msg = f"Robot did not confirm completion (D) for command {i+1}. Got: '{response_d}'"
                        logging.error(error_msg)
                        self.window.after(0, lambda: messagebox.showerror("Test Failed", error_msg))
                        break
                else:
                    error_msg = f"Robot did not confirm receipt (R) for command {i+1}. Got: '{response_r}'"
                    logging.error(error_msg)
                    self.window.after(0, lambda: messagebox.showerror("Test Failed", error_msg))
                    break
            else:
                self.window.after(0, lambda: messagebox.showerror("Connection Error", "Failed to send test command. Connection may be lost."))
                break
        
        if button_to_re_enable and button_to_re_enable.winfo_exists():
            self.window.after(0, lambda: button_to_re_enable.config(state=tk.NORMAL, text=original_text))
        logging.info(f"Sequence '{original_text}' finished.")


    def capture_image_page(self):
        self.clear_frame()
        tk.Label(self.main_frame, text="Camera View", font=("Arial", 16)).pack(pady=5)

        self.camera_frame_label = tk.Label(self.main_frame)
        self.camera_frame_label.pack(pady=10)

        button_frame = tk.Frame(self.main_frame)
        button_frame.pack(pady=5)

        self.capture_button = tk.Button(button_frame, text="Capture (S)", command=self.capture_action)
        self.capture_button.pack(side=tk.LEFT, padx=5)
        self.camera_back_button = tk.Button(button_frame, text="Back", command=self.stop_camera_and_go_back)
        self.camera_back_button.pack(side=tk.LEFT, padx=5)

        self.window.bind('s', self.capture_action_event)
        self.window.bind('S', self.capture_action_event)

        self.start_camera_feed()

    def start_camera_feed(self):
        if self.camera_running: return

        try:
            self.cap = cv2.VideoCapture(0)
            if not self.cap.isOpened():
                messagebox.showerror("Camera Error", "Could not open camera.")
                self.stop_camera_and_go_back()
                return
            self.camera_running = True
            self._update_camera_frame()
        except Exception as e:
            messagebox.showerror("Camera Error", f"Error initializing camera: {e}")
            self.stop_camera_and_go_back()

    def _update_camera_frame(self):
        if not self.camera_running or not self.cap:
            return

        ret, frame = self.cap.read()
        if ret:
            cv_image = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            pil_image = Image.fromarray(cv_image)
            imgtk = ImageTk.PhotoImage(image=pil_image)

            if self.camera_frame_label:
                self.camera_frame_label.imgtk = imgtk
                self.camera_frame_label.configure(image=imgtk)
        else:
            logging.warning("Failed to grab frame from camera.")

        if self.camera_running:
            self.window.after(30, self._update_camera_frame)

    def stop_camera_feed(self):
        self.camera_running = False
        time.sleep(0.1)
        if self.cap:
            self.cap.release()
            self.cap = None

    def stop_camera_and_go_back(self):
        self.stop_camera_feed()
        self.window.unbind('s')
        self.window.unbind('S')
        self.drawing_options_page()

    def capture_action_event(self, event=None):
        self.capture_action()

    def capture_action(self):
        if not self.camera_running or not self.cap:
            messagebox.showwarning("Capture Error", "Camera not running.")
            return

        ret, frame = self.cap.read()
        self.stop_camera_feed()
        self.window.unbind('s')
        self.window.unbind('S')

        if ret:
            try:
                os.makedirs(DATA_DIR, exist_ok=True)
                cv2.imwrite(TMP_CAPTURE_PATH, frame)
                logging.info(f"Image captured and saved to {TMP_CAPTURE_PATH}")
                self.current_image_path = TMP_CAPTURE_PATH
                self.show_threshold_options(self.current_image_path)
            except Exception as e:
                messagebox.showerror("Save Error", f"Could not save captured image: {e}")
                self.drawing_options_page()
        else:
            messagebox.showerror("Capture Error", "Failed to capture frame from camera.")
            self.drawing_options_page()

    def input_image_page(self):
        self.clear_frame()
        tk.Label(self.main_frame, text="Input Image to Draw", font=("Arial", 16)).pack(pady=10)

        entry_frame = tk.Frame(self.main_frame)
        entry_frame.pack(pady=5, fill='x', padx=10)
        tk.Label(entry_frame, text="Image Path:").pack(side=tk.LEFT)
        self.image_path_var = tk.StringVar()
        path_entry = tk.Entry(entry_frame, textvariable=self.image_path_var, width=50)
        path_entry.pack(side=tk.LEFT, fill='x', expand=True, padx=5)
        tk.Button(entry_frame, text="Browse...", command=self.browse_image_file).pack(side=tk.LEFT)

        tk.Button(self.main_frame, text="Process Image", command=self.process_input_image, width=20).pack(pady=10)
        tk.Button(self.main_frame, text="Back", command=self.drawing_options_page, width=20).pack(pady=10)

    def browse_image_file(self):
        filepath = filedialog.askopenfilename(
            title="Select Image to Draw",
            filetypes=[("Image Files", "*.png *.jpg *.jpeg *.bmp *.gif"), ("All Files", "*.*")]
        )
        if filepath:
            self.image_path_var.set(filepath)

    def process_input_image(self):
        filepath = self.image_path_var.get()
        if not filepath or not os.path.isfile(filepath):
            messagebox.showerror("Error", f"Invalid or non-existent file path:\n{filepath}")
            return
        self.current_image_path = filepath
        self.show_threshold_options(self.current_image_path)

    def show_threshold_options(self, image_path):
        self.clear_frame()
        tk.Label(self.main_frame, text="Select Drawing Style (Thresholds)", font=("Arial", 16)).pack(pady=10)

        self.threshold_options_data = {}
        self.selected_threshold_option = tk.StringVar(value=None)
        self.preview_label = tk.Label(self.main_frame)
        self.preview_label.pack(pady=5)

        options_frame = tk.Frame(self.main_frame)
        options_frame.pack(pady=5)

        loading_label = tk.Label(options_frame, text="Processing options...")
        loading_label.pack()
        self.window.update()

        try:
            pen_down_z = float(self.test_z_var.get())
            logging.info(f"Using custom pen down Z for drawing path generation: {pen_down_z}")
        except (ValueError, tk.TclError):
            logging.warning("Invalid or no custom Z value found, using default.")
            pen_down_z = PEN_DOWN_Z

        threading.Thread(target=self._process_threshold_options_thread, args=(image_path, options_frame, loading_label, pen_down_z), daemon=True).start()

    def _process_threshold_options_thread(self, image_path, options_frame, loading_label, pen_down_z):
        results = {}
        preview_paths = {}

        for i, (label, t1, t2) in enumerate(THRESHOLD_OPTIONS):
            logging.info(f"Processing option: {label} (t1={t1}, t2={t2})")
            preview_path = TMP_EDGE_OUTPUT_PATH.format(i)
            contours_xy, w, h = image_to_contours_internal(image_path, t1, t2, save_edge_path=preview_path)

            if contours_xy is None or w == 0 or h == 0:
                logging.warning(f"Failed to process contours for option {label}")
                results[label] = None
                preview_paths[label] = None
                continue

            commands = create_drawing_paths(contours_xy, w, h, pen_down_z, optimize_paths=True)
            if commands:
                num_commands = len(commands)
                est_time_sec = num_commands * TIME_ESTIMATE_FACTOR
                est_time_min = est_time_sec / 60
                results[label] = {
                    "commands": commands,
                    "count": num_commands,
                    "time_str": f"{est_time_min:.1f} min",
                    "t1": t1,
                    "t2": t2
                }
                preview_paths[label] = preview_path if os.path.exists(preview_path) else None
            else:
                results[label] = None
                preview_paths[label] = None
                logging.warning(f"No commands generated for option {label}")

        self.window.after(0, lambda: self._display_threshold_options(options_frame, loading_label, results, preview_paths))

    def _display_threshold_options(self, options_frame, loading_label, results, preview_paths):
        loading_label.destroy()

        self.threshold_options_data = results
        self.edge_preview_paths = preview_paths

        default_selected = False
        for i, (label, t1, t2) in enumerate(THRESHOLD_OPTIONS):
            option_data = results.get(label)
            if option_data:
                count = option_data["count"]
                time_str = option_data["time_str"]
                radio_text = f"{label} (t1={t1}, t2={t2}) - Cmds: {count}, Est: {time_str}"
                rb = tk.Radiobutton(
                    options_frame,
                    text=radio_text,
                    variable=self.selected_threshold_option,
                    value=label,
                    command=lambda l=label: self.show_edge_preview(l)
                )
                rb.pack(anchor='w')
                if not default_selected:
                    self.selected_threshold_option.set(label)
                    self.show_edge_preview(label)
                    default_selected = True
            else:
                tk.Label(options_frame, text=f"{label} (t1={t1}, t2={t2}) - No drawing generated", fg="gray").pack(anchor='w')

        button_frame = tk.Frame(self.main_frame)
        button_frame.pack(pady=10)
        tk.Button(button_frame, text="Confirm and Draw", command=self.confirm_and_start_drawing, width=20).pack(side=tk.LEFT, padx=5)
        tk.Button(button_frame, text="Save Points to File", command=self.save_points_to_file, width=20).pack(side=tk.LEFT, padx=5)
        tk.Button(button_frame, text="Back", command=self.drawing_options_page, width=20).pack(side=tk.LEFT, padx=5)

    def save_points_to_file(self):
        """Saves the generated drawing commands for the selected option to a text file."""
        selected_label = self.selected_threshold_option.get()
        if not selected_label:
            messagebox.showwarning("Selection Needed", "Please select a drawing style option first.")
            return

        option_data = self.threshold_options_data.get(selected_label)
        if not option_data or not option_data.get("commands"):
            messagebox.showerror("Error", "Selected option has no drawing commands to save.")
            return

        commands = option_data["commands"]
        
        filepath = filedialog.asksaveasfilename(
            title="Save Drawing Points",
            defaultextension=".txt",
            filetypes=[("Text Files", "*.txt"), ("All Files", "*.*")],
            initialfile="drawing_points.txt"
        )

        if not filepath:
            # User cancelled the save dialog
            return

        try:
            with open(filepath, 'w') as f:
                # Format as a tuple of tuples: ((x,y,z),(x,y,z),...)
                points_str = ",".join([f"({x:.2f},{y:.2f},{z:.2f})" for x, y, z in commands])
                f.write(f"({points_str})")
            
            messagebox.showinfo("Success", f"Drawing points successfully saved to:\n{filepath}")
        except Exception as e:
            messagebox.showerror("Save Error", f"Could not save the file.\nError: {e}")

    def show_edge_preview(self, option_label):
        preview_path = self.edge_preview_paths.get(option_label)
        if preview_path and os.path.exists(preview_path):
            try:
                img = Image.open(preview_path)
                img.thumbnail((300, 300))
                imgtk = ImageTk.PhotoImage(image=img)
                self.preview_label.imgtk = imgtk
                self.preview_label.configure(image=imgtk)
            except Exception as e:
                logging.error(f"Error loading preview image {preview_path}: {e}")
                self.preview_label.configure(image=None, text="Preview error")
        else:
            self.preview_label.configure(image=None, text="No Preview")

    def confirm_and_start_drawing(self):
        selected_label = self.selected_threshold_option.get()
        if not selected_label:
            messagebox.showwarning("Selection Needed", "Please select a drawing style option.")
            return

        option_data = self.threshold_options_data.get(selected_label)
        if not option_data or not option_data.get("commands"):
            messagebox.showerror("Error", "Selected option has no drawing commands.")
            return

        self.selected_commands = option_data["commands"]

        if not self.drawing_in_progress:
            self.drawing_in_progress = True
            self.cancel_requested = False
            self.resume_needed = False
            self.pause_event.set()
            
            try:
                pen_down_z = float(self.test_z_var.get())
            except (ValueError, tk.TclError):
                pen_down_z = PEN_DOWN_Z

            full_command_list = self.selected_commands + create_signature_commands(SIGNATURE_WAYPOINTS, pen_down_z)
            
            # --- ETA Calculation ---
            self.total_estimated_time = len(full_command_list) * TIME_ESTIMATE_FACTOR
            self.drawing_start_time = time.time()
            self.total_paused_time = 0
            self.pause_start_time = 0
            
            threading.Thread(target=self.run_drawing_loop, args=(full_command_list,), daemon=True).start()
            self.show_drawing_progress_page(len(full_command_list))
        else:
            messagebox.showwarning("Busy", "Drawing already in progress.")

    def show_drawing_progress_page(self, total_commands, current_progress=0):
        self.clear_frame()
        tk.Label(self.main_frame, text="Drawing in Progress...", font=("Arial", 16)).pack(pady=10)

        self.status_label = tk.Label(self.main_frame, textvariable=self.progress_text_var)
        self.status_label.pack(pady=5)

        self.progress_bar = ttk.Progressbar(self.main_frame, orient="horizontal", length=300, mode="determinate", maximum=total_commands, value=current_progress)
        self.progress_bar.pack(pady=10)

        controls_frame = tk.Frame(self.main_frame)
        controls_frame.pack(pady=5)

        self.pause_resume_button = tk.Button(controls_frame, text="Pause", command=self.toggle_pause_resume, width=15)
        self.pause_resume_button.pack(side=tk.LEFT, padx=5)
        
        self.cancel_button = tk.Button(controls_frame, text="Cancel Drawing", command=self.request_cancel_drawing, width=15)
        self.cancel_button.pack(side=tk.LEFT, padx=5)

        # Start the ETA update loop
        self.update_drawing_status(current_progress, total_commands)
        self._update_eta_countdown()


    def _update_eta_countdown(self):
        """Periodically updates the ETA label with a dynamic estimate."""
        if not self.drawing_in_progress:
            return

        completed_cmds = self.progress_bar['value']
        total_cmds = self.progress_bar['maximum']
        
        remaining_time = 0
        
        # Only calculate dynamic ETA after a few commands have completed for stability
        if completed_cmds > 5:
            # Calculate total time spent actively drawing (excluding pauses)
            active_drawing_time = (time.time() - self.drawing_start_time) - self.total_paused_time
            avg_time_per_cmd = active_drawing_time / completed_cmds
            remaining_cmds = total_cmds - completed_cmds
            remaining_time = remaining_cmds * avg_time_per_cmd
        else:
            # For the beginning, use the initial static estimate
            elapsed_time = (time.time() - self.drawing_start_time) - self.total_paused_time
            initial_total_time = total_cmds * TIME_ESTIMATE_FACTOR
            remaining_time = initial_total_time - elapsed_time

        if remaining_time < 0:
            remaining_time = 0

        mins, secs = divmod(int(remaining_time), 60)
        time_str = f"{mins:02d}:{secs:02d}"
        
        # Update the full progress text
        self.progress_text_var.set(f"Sent {completed_cmds} / {total_cmds} commands | ETA: {time_str}")

        # Schedule the next update
        self.eta_update_id = self.window.after(1000, self._update_eta_countdown)


    def toggle_pause_resume(self):
        if self.pause_event.is_set():
            # --- PAUSING ---
            self.pause_event.clear()
            logging.info("Drawing paused by user.")
            if self.pause_resume_button and self.pause_resume_button.winfo_exists():
                self.pause_resume_button.config(text="Resume")
            
            # Record when the pause started
            self.pause_start_time = time.time()
            
            # Stop the timer when paused
            if self.eta_update_id:
                self.window.after_cancel(self.eta_update_id)
                self.eta_update_id = None
        else:
            # --- RESUMING ---
            self.pause_event.set()
            logging.info("Drawing resumed by user.")
            if self.pause_resume_button and self.pause_resume_button.winfo_exists():
                self.pause_resume_button.config(text="Pause")
            
            # Add the duration of the pause to the total paused time
            if self.pause_start_time > 0:
                paused_duration = time.time() - self.pause_start_time
                self.total_paused_time += paused_duration
                self.pause_start_time = 0 # Reset for next pause

            # Restart the timer when resumed
            self._update_eta_countdown()

    def update_drawing_status(self, current_command_index, total_commands):
        """Updates the progress bar. The label is handled by the ETA loop."""
        if self.progress_bar and self.progress_bar.winfo_exists():
            self.progress_bar['value'] = current_command_index
        
        # The text variable is now updated entirely by the _update_eta_countdown loop
        # to prevent race conditions and keep the display smooth.

    def request_cancel_drawing(self):
        if self.drawing_in_progress:
            logging.info("Cancel requested by user.")
            self.cancel_requested = True
            self.pause_event.set() # Unblock the drawing loop so it can see the flag
            if self.cancel_button and self.cancel_button.winfo_exists():
                self.cancel_button.config(text="Cancelling...", state=tk.DISABLED)
            if self.pause_resume_button and self.pause_resume_button.winfo_exists():
                self.pause_resume_button.config(state=tk.DISABLED)
            if self.status_label and self.status_label.winfo_exists():
                self.progress_text_var.set("Cancellation requested...")

    def _send_final_position_and_cleanup(self, success_message, failure_message):
        self.drawing_in_progress = False # Stop the ETA loop
        logging.info("Attempting to move robot to final position.")
        # Standardized to (X, Y, Z)
        final_x, final_y, final_z = FINAL_ROBOT_POSITION
        byte_data = struct.pack('!fff', final_x, final_y, final_z)

        move_ok = False
        if self.connected and self.socket:
            if self.send_message_internal(byte_data):
                response_r_final = self.receive_message_internal(timeout=None)
                if response_r_final == "R":
                    response_d_final = self.receive_message_internal(timeout=None)
                    if response_d_final == "D":
                        logging.info("Robot reached final position.")
                        move_ok = True
                    else:
                        logging.error(f"Robot didn't confirm final move completion (D), got '{response_d_final}'")
                else:
                    logging.error(f"Robot didn't confirm final move receipt (R), got '{response_r_final}'")
            else:
                logging.error("Failed to send final position command.")

        final_status = ""
        if move_ok:
            final_status = f"{success_message} Robot at final position."
        else:
            final_status = f"{failure_message} Failed to reach final position."

        self.last_drawing_status["status"] = success_message
        self.last_drawing_status["error_message"] = "" if move_ok else "Failed to reach final position."

        self.window.after(0, lambda fs=final_status: self.update_final_status(fs))

        self.selected_commands = None
        self.cancel_requested = False
        if not self.resume_needed:
            self.resume_commands = None
            self.resume_total_original_commands = 0
            self.resume_start_index_global = 0

        self.window.after(2000, self.drawing_options_page)

    def update_final_status(self, message):
        if self.eta_update_id:
            self.window.after_cancel(self.eta_update_id)
            self.eta_update_id = None
        if self.status_label and self.status_label.winfo_exists():
            self.progress_text_var.set(message)
        if self.cancel_button and self.cancel_button.winfo_exists():
            self.cancel_button.pack_forget()
        if self.pause_resume_button and self.pause_resume_button.winfo_exists():
            self.pause_resume_button.pack_forget()

    def run_drawing_loop(self, commands_to_send: List[Tuple], start_index=0):
        """Sends drawing commands one by one using the byte protocol."""
        total_commands = len(commands_to_send)
        
        if start_index > 0:
            self.window.after(0, lambda: self.show_drawing_progress_page(total_commands, start_index))
        
        try:
            # Standardized to (X, Y, Z)
            for i, (x, y, z) in enumerate(commands_to_send[start_index:]):
                self.pause_event.wait()
                if self.cancel_requested:
                    logging.info("Cancellation detected in drawing loop.")
                    # Call the cleanup function to move to a final safe position and reset the UI
                    self._send_final_position_and_cleanup("Drawing Cancelled.", "Drawing Cancelled.")
                    return

                current_command_global_index = start_index + i
                
                # Standardized to pack (X, Y, Z)
                byte_data = struct.pack('!fff', x, y, z)

                if not self.send_message_internal(byte_data):
                    logging.error(f"Connection lost while sending command. Preparing to resume.")
                    self.drawing_in_progress = False # Stop ETA loop
                    self.resume_needed = True
                    self.resume_commands = commands_to_send
                    self.resume_start_index_global = current_command_global_index
                    return

                response_r = self.receive_message_internal(timeout=10.0)
                if response_r != "R":
                    logging.error(f"Robot did not confirm receipt (R), got '{response_r}'.")
                    self.drawing_in_progress = False
                    return
                
                response_d = self.receive_message_internal(timeout=None)
                if response_d != "D":
                    logging.error(f"Robot did not confirm completion (D), got '{response_d}'.")
                    self.drawing_in_progress = False
                    return
                
                # Update the progress bar value. The label text is handled by the ETA loop.
                self.window.after(0, lambda p=current_command_global_index + 1: self.update_drawing_status(p, total_commands))

            logging.info("All drawing commands sent successfully.")
            self._send_final_position_and_cleanup("Drawing Complete.", "Drawing Complete.")

        except Exception as e:
            logging.error(f"Unexpected error during drawing process: {e}", exc_info=True)
            self.drawing_in_progress = False

    def send_message_internal(self, message: bytes) -> bool:
        """ Sends byte data without triggering GUI popups on error. Returns success status. """
        if not self.connected or not self.socket: return False
        try:
            self.socket.sendall(message)
            return True
        except (socket.error, ConnectionResetError, BrokenPipeError, socket.timeout) as e:
            logging.error(f"Send error (internal): {e}")
            self.handle_connection_loss()
            return False

    def receive_message_internal(self, timeout=None) -> Optional[str]:
        if not self.connected or not self.socket: return None
        try:
            self.socket.settimeout(timeout)
            data = self.socket.recv(1024)
            self.socket.settimeout(None)
            if not data:
                logging.warning("Receive error (internal): Connection closed by peer.")
                self.handle_connection_loss()
                return None
            decoded_data = data.decode('utf-8').strip()
            return decoded_data
        except socket.timeout:
            logging.error(f"Timeout receiving message (internal)")
            return None
        except (socket.error, ConnectionResetError, BrokenPipeError) as e:
            logging.error(f"Receive error (internal): {e}")
            self.handle_connection_loss()
            return None

    def handle_connection_loss(self):
        logging.warning("Connection lost detected.")
        was_connected = self.connected
        self.close_socket()
        if was_connected and not self.drawing_in_progress and not self.resume_needed:
            self.window.after(0, lambda: messagebox.showinfo("Connection Lost", "Robot connection lost."))

    def establish_connection(self):
        if hasattr(self, 'connect_button') and self.connect_button.winfo_exists(): self.connect_button.config(state=tk.DISABLED)
        if hasattr(self, 'reconnect_button') and self.reconnect_button.winfo_exists(): self.reconnect_button.config(state=tk.DISABLED)

        host, port = (SIMULATION_HOST, SIMULATION_PORT) if self.connection_var.get() == "simulation" else (REAL_ROBOT_HOST, REAL_ROBOT_PORT)

        def connection_attempt():
            try:
                self.close_socket()
                self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                self.socket.settimeout(5)
                self.socket.connect((host, port))
                self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                self.socket.settimeout(None)
                logging.info(f"Connected to {host}:{port}")
                self.connected = True
                self.window.after(0, lambda: self.handle_connection_result(True))
            except (socket.error, socket.timeout, ConnectionRefusedError) as e:
                logging.error(f"Connection error: {e}")
                self.connected = False
                self.close_socket()
                self.window.after(0, lambda: self.handle_connection_result(False))
        threading.Thread(target=connection_attempt, daemon=True).start()

    def handle_connection_result(self, connected):
        if hasattr(self, 'connect_button') and self.connect_button.winfo_exists():
            self.connect_button.config(state=tk.NORMAL)
        if hasattr(self, 'reconnect_button') and self.reconnect_button.winfo_exists():
            self.reconnect_button.config(state=tk.NORMAL)

        if connected:
            self.connection_established = True
            if self.resume_needed and self.resume_commands is not None:
                logging.info("Reconnection successful. Preparing to resume drawing.")
                self.move_to_final_before_resume()
            else:
                self.drawing_options_page()
        else:
            if self.resume_needed:
                messagebox.showerror("Reconnection Failed", "Failed to reconnect. Cannot resume the previous drawing.")
                self.resume_needed = False
                self.resume_commands = None
                self.resume_total_original_commands = 0
                self.resume_start_index_global = 0
                self.last_drawing_status["status"] = "Resume Failed"
                self.last_drawing_status["error_message"] = "Could not reconnect to robot."
                self.drawing_options_page()
            else:
                messagebox.showerror("Connection Failed", "Failed to establish connection.")

    def move_to_final_before_resume(self):
        def move_and_resume_thread():
            logging.info("Moving robot to FINAL_ROBOT_POSITION before resuming...")
            self.show_drawing_progress_page(self.resume_total_original_commands, self.resume_start_index_global)

            # Standardized to (X, Y, Z)
            final_x, final_y, final_z = FINAL_ROBOT_POSITION
            byte_data = struct.pack('!fff', final_x, final_y, final_z)
            move_ok = False
            if self.connected and self.socket:
                if self.send_message_internal(byte_data):
                    response_r = self.receive_message_internal(timeout=5.0)
                    if response_r == "R":
                        response_d = self.receive_message_internal(timeout=5.0)
                        if response_d == "D":
                            logging.info("Robot reached FINAL_ROBOT_POSITION.")
                            move_ok = True
                        else: logging.error("Failed to get 'D' confirmation for pre-resume move.")
                    else: logging.error("Failed to get 'R' confirmation for pre-resume move.")
                else: logging.error("Failed to send pre-resume move command.")

            if move_ok:
                logging.info(f"Starting resume from command index {self.resume_start_index_global}")
                self.drawing_in_progress = True
                self.cancel_requested = False
                self.pause_event.set()
                self.run_drawing_loop(self.resume_commands, self.resume_start_index_global)
            else:
                error_msg = "Failed to move robot to safe resume position."
                logging.error(error_msg + " Cannot resume automatically, but allowing retry.")
                self.last_drawing_status["status"] = "Resume Failed (Pre-move)"
                self.last_drawing_status["error_message"] = error_msg
                self.window.after(0, lambda: messagebox.showwarning("Resume Warning", error_msg + "\nConnection might be unstable. You can try 'Reconnect & Resume' again."))
                self.drawing_in_progress = False
                self.window.after(1000, self.connection_setup_page)

        threading.Thread(target=move_and_resume_thread, daemon=True).start()

    def close_socket(self):
        if self.socket:
            try:
                self.socket.shutdown(socket.SHUT_RDWR)
            except (socket.error, OSError): pass
            finally:
                try: self.socket.close()
                except (socket.error, OSError): pass
                self.socket = None
                logging.info("Socket closed")
        self.connected = False
        self.connection_established = False

    def close_and_return_main(self):
        self.pause_event.set()
        self.close_socket()
        self.resume_needed = False
        self.resume_commands = None
        self.resume_total_original_commands = 0
        self.resume_start_index_global = 0
        self.main_page()

    def clear_frame(self):
        if self.camera_running:
            self.stop_camera_feed()
        # Cancel any pending ETA update
        if self.eta_update_id:
            self.window.after_cancel(self.eta_update_id)
            self.eta_update_id = None
        for widget in self.main_frame.winfo_children():
            widget.destroy()
        self.camera_frame_label = None
        self.capture_button = None
        self.camera_back_button = None
        self.progress_bar = None
        self.status_label = None
        self.cancel_button = None
        self.connect_button = None
        self.reconnect_button = None
        self.preview_label = None
        self.pause_resume_button = None

    def on_window_close(self):
        logging.info("Window close requested.")
        self.cancel_requested = True
        self.drawing_in_progress = False # Stop ETA loop
        self.pause_event.set()
        self.stop_camera_feed()
        self.close_socket()
        time.sleep(0.2)
        self.window.destroy()

if __name__ == "__main__":
    os.makedirs(DATA_DIR, exist_ok=True)
    app = RUNME_GUI()
    app.window.protocol("WM_DELETE_WINDOW", app.on_window_close)
    app.window.mainloop()

--- END OF FILE: testing/main.py ---
--- START OF FILE: testing/.gitignore ---
temp_edges_0.png
temp_edges_1.png
temp_edges_2.png
temp_edges_3.png
temp_edges_4.png
temp_edges_5.png
temp_edges_6.png

--- END OF FILE: testing/.gitignore ---
--- START OF FILE: testing/main_without_R.py ---
import tkinter as tk
from tkinter import messagebox, filedialog, ttk
import os
import threading
import time
import logging
import socket
import struct # Import the struct module for packing data
from concurrent.futures import ThreadPoolExecutor
from typing import List, Tuple, Optional
import cv2
import numpy as np
import math
from PIL import Image, ImageTk

# Configure logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")

# --- Constants (Consolidated) ---
SCRIPT_DIR = os.getenv("SCRIPT_DIR", ".")
DATA_DIR = os.getenv("DATA_DIR", ".")

TMP_CAPTURE_PATH = os.path.join(DATA_DIR, "temp_capture.png")
TMP_EDGE_OUTPUT_PATH = os.path.join(DATA_DIR, "temp_edges_{}.png")

REAL_ROBOT_HOST = '192.168.125.1'
REAL_ROBOT_PORT = 1025
SIMULATION_HOST = '127.0.0.1'
SIMULATION_PORT = 55000

# Drawing Specific Constants
# Standardized to (X, Y, Z)
FINAL_ROBOT_POSITION = (0, 0, -350)
A4_WIDTH_MM = 180
A4_HEIGHT_MM = 217
# This is now a DEFAULT value, which can be overridden by the GUI.
PEN_DOWN_Z = -14 
PEN_UP_Z = - 1.3 * PEN_DOWN_Z 
MIN_CONTOUR_LENGTH_PX = 1

# Threshold options
THRESHOLD_OPTIONS = [
    ("Option {}".format(i), i*10, i*20) for i in range(1, 8)
]

# Time estimation factor
TIME_ESTIMATE_FACTOR = 0.018

# Waypoints for the signature drawing, using specific Z-depths.
SIGNATURE_WAYPOINTS = ((0, 0, -70),)


def create_signature_commands(waypoints, pen_down_z):
    """Converts signature waypoints into robot commands, handling pen up/down moves."""
    pen_up_z = -1.3 * pen_down_z
    if pen_up_z == 0:
        pen_up_z = -3
    commands = []
    if not waypoints:
        return commands

    # Move to the starting XY of the signature with the pen up
    start_x, start_y, _ = waypoints[0]
    commands.append((start_x, start_y, pen_up_z))

    # Add the actual drawing waypoints
    for point in waypoints:
        commands.append(point)

    # Lift the pen at the end of the signature
    if commands:
        last_x, last_y, _ = waypoints[-1]
        commands.append((last_x, last_y, pen_up_z))
    return commands


def calculate_distance(p1, p2):
    """Calculates Euclidean distance between two points (x, y)."""
    if p1 is None or p2 is None: return float('inf')
    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)


def image_to_contours_internal(image_path_or_array, threshold1, threshold2, save_edge_path=None):
    if isinstance(image_path_or_array, str):
        image = cv2.imread(image_path_or_array, cv2.IMREAD_GRAYSCALE)
    elif isinstance(image_path_or_array, np.ndarray):
        if len(image_path_or_array.shape) == 3:
            image = cv2.cvtColor(image_path_or_array, cv2.COLOR_BGR2GRAY)
        else:
            image = image_path_or_array
    else:
        logging.error("Invalid input type for image_to_contours_internal")
        return None, 0, 0

    if image is None:
        logging.error(f"Could not read or process image input.")
        return None, 0, 0

    image_height, image_width = image.shape[:2]
    if image_height == 0 or image_width == 0:
        logging.error("Invalid image dimensions.")
        return None, 0, 0

    blurred = cv2.GaussianBlur(image, (5, 5), 0)
    edges = cv2.Canny(blurred, threshold1, threshold2)

    if save_edge_path:
        try:
            cv2.imwrite(save_edge_path, edges)
        except Exception as e:
            logging.error(f"Failed to save edge image to {save_edge_path}: {e}")

    contours, _ = cv2.findContours(edges, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)
    filtered_contours = [c for c in contours if cv2.arcLength(c, closed=False) > MIN_CONTOUR_LENGTH_PX]

    contours_xy = []
    for contour in filtered_contours:
        points = contour.squeeze().tolist()
        if not isinstance(points, list) or not points: continue
        if isinstance(points[0], int):
            points = [points]
        contours_xy.append([(p[0], p[1]) for p in points if isinstance(p, (list, tuple)) and len(p) == 2])

    contours_xy = [c for c in contours_xy if c]
    return contours_xy, image_width, image_height


def scale_point_to_a4(point_xy, image_width, image_height, scale_factor):
    x_pixel, y_pixel = point_xy
    center_x_pixel = image_width / 2
    center_y_pixel = image_height / 2
    x_centered_pixel = x_pixel - center_x_pixel
    y_centered_pixel = center_y_pixel - y_pixel
    x_mm = x_centered_pixel * scale_factor
    y_mm = y_centered_pixel * scale_factor
    return (x_mm, y_mm)


def create_drawing_paths(contours_xy, image_width, image_height, pen_down_z, optimize_paths=True):
    """Generates robot drawing paths using a specific Z-height for pen-down moves."""
    if not contours_xy or image_width <= 0 or image_height <= 0:
        return []

    pen_up_z = - 1.3 * pen_down_z
    if pen_up_z == 0:
        pen_up_z = -3

    scale_x = A4_WIDTH_MM / image_width
    scale_y = A4_HEIGHT_MM / image_height
    scale_factor = min(scale_x, scale_y)

    scaled_contours = []
    for contour in contours_xy:
        if not contour: continue
        scaled_contour = [scale_point_to_a4(p, image_width, image_height, scale_factor) for p in contour]
        if len(scaled_contour) >= 2:
            scaled_contours.append(scaled_contour)
        elif len(scaled_contour) == 1:
            scaled_contours.append([scaled_contour[0], scaled_contour[0]])

    if not scaled_contours:
        return []

    ordered_contours = []
    last_point = None
    if optimize_paths:
        remaining_contours = list(scaled_contours)
        if remaining_contours:
            current_contour = remaining_contours.pop(0)
            ordered_contours.append(current_contour)
            last_point = current_contour[-1]

            while remaining_contours:
                best_dist = float('inf')
                best_idx = -1
                best_reversed = False

                for i, contour in enumerate(remaining_contours):
                    start_point = contour[0]
                    end_point = contour[-1]
                    dist_start = calculate_distance(last_point, start_point)
                    dist_end = calculate_distance(last_point, end_point)

                    if dist_start < best_dist:
                        best_dist = dist_start
                        best_idx = i
                        best_reversed = False
                    if dist_end < best_dist:
                        best_dist = dist_end
                        best_idx = i
                        best_reversed = True

                if best_idx != -1:
                    next_contour = remaining_contours.pop(best_idx)
                    if best_reversed:
                        next_contour.reverse()
                    ordered_contours.append(next_contour)
                    last_point = next_contour[-1]
                else:
                    logging.warning("Path optimization loop finished unexpectedly.")
                    break
        scaled_contours = ordered_contours
    else:
        scaled_contours = [c for c in scaled_contours]

    robot_commands = []
    for contour in scaled_contours:
        if not contour: continue
        start_point = contour[0]
        # Standardized to (X, Y, Z)
        robot_commands.append((start_point[0], start_point[1], pen_up_z))
        robot_commands.append((start_point[0], start_point[1], pen_down_z))

        for i in range(len(contour) - 1):
            end_point = contour[i+1]
            if end_point != contour[i]:
                # Standardized to (X, Y, Z)
                robot_commands.append((end_point[0], end_point[1], pen_down_z))

        final_point = contour[-1]
        # Standardized to (X, Y, Z)
        robot_commands.append((final_point[0], final_point[1], pen_up_z))

    return robot_commands


class RUNME_GUI:
    """Main GUI application for the Robotics System."""

    def __init__(self):
        self.window = tk.Tk()
        self.window.title("Robotics Drawing GUI")
        self.main_frame = tk.Frame(self.window)
        self.main_frame.pack(pady=20, padx=20, fill="both", expand=True)

        self.connection_var = tk.StringVar(value="simulation")
        self.socket = None
        self.connected = False
        self.connection_established = False

        self.cap = None
        self.camera_running = False
        self.camera_frame_label = None
        self.capture_button = None
        self.camera_back_button = None

        self.current_image_path = None
        self.threshold_options_data = {}
        self.selected_commands = None
        self.drawing_in_progress = False
        self.cancel_requested = False
        self.progress_bar = None
        self.status_label = None
        self.cancel_button = None
        self.reconnect_button = None
        
        self.test_z_var = tk.StringVar(value=str(PEN_DOWN_Z))
        
        self.pause_event = threading.Event()
        self.pause_resume_button = None

        self.last_drawing_status = {
            "total_commands": 0,
            "completed_commands": 0,
            "status": "None",
            "error_message": ""
        }
        
        self.resume_needed = False
        self.resume_commands = None
        self.resume_total_original_commands = 0
        self.resume_start_index_global = 0

        # --- ETA Countdown variables ---
        self.eta_update_id = None
        self.drawing_start_time = 0
        self.total_paused_time = 0
        self.pause_start_time = 0
        self.progress_text_var = tk.StringVar()


        self.main_page()

    def main_page(self):
        self.clear_frame()
        tk.Label(self.main_frame, text="Robotics Drawing System", font=("Arial", 16)).pack(pady=10)
        tk.Button(self.main_frame, text="Setup Connection & Draw",
                  command=self.connection_setup_page, width=30).pack(pady=5)
        tk.Button(self.main_frame, text="Exit",
                  command=self.on_window_close, width=30).pack(pady=5)

    def connection_setup_page(self):
        self.clear_frame()
        tk.Label(self.main_frame, text="Robot Connection Setup", font=("Arial", 16)).pack(pady=10)

        connection_frame = tk.Frame(self.main_frame)
        connection_frame.pack(pady=10)
        tk.Radiobutton(connection_frame, text=f"Simulation: {SIMULATION_HOST}:{SIMULATION_PORT}",
                       variable=self.connection_var, value="simulation").pack(anchor='w')
        tk.Radiobutton(connection_frame, text=f"Real Robot: {REAL_ROBOT_HOST}:{REAL_ROBOT_PORT}",
                       variable=self.connection_var, value="real").pack(anchor='w')

        self.connect_button = tk.Button(self.main_frame, text="Connect", command=self.establish_connection, width=20)
        self.reconnect_button = tk.Button(self.main_frame, text="Reconnect & Resume", command=self.establish_connection, width=20)

        if self.resume_needed:
            self.reconnect_button.pack(pady=5)
            tk.Label(self.main_frame, text="Connection lost during last drawing. Reconnect to resume.", fg="orange").pack()
        else:
            self.connect_button.pack(pady=5)

        tk.Button(self.main_frame, text="Back", command=self.main_page, width=20).pack(pady=5)

    def drawing_options_page(self):
        if not self.connection_established:
            messagebox.showerror("Connection Required", "Please establish connection first.")
            self.connection_setup_page()
            return

        self.clear_frame()
        tk.Label(self.main_frame, text="Robot Drawing Options", font=("Arial", 16)).pack(pady=10)
        conn_type = "Simulation" if self.connection_var.get() == "simulation" else "Real Robot"
        tk.Label(self.main_frame, text=f"Connected to: {conn_type}", fg="green").pack(pady=5)
        last_status = self.last_drawing_status["status"]
        if last_status not in ["None", "Completed"]:
            status_frame = tk.Frame(self.main_frame, relief=tk.RIDGE, borderwidth=2)
            status_frame.pack(pady=10, padx=10, fill='x')
            tk.Label(status_frame, text="Previous Drawing Status:", font=("Arial", 10, "bold")).pack(anchor='w')
            status_text = f"Status: {last_status}"
            if self.last_drawing_status["total_commands"] > 0:
                status_text += f" (Stopped at command {self.last_drawing_status['completed_commands'] + 1}" \
                               f" of {self.last_drawing_status['total_commands']})"
            tk.Label(status_frame, text=status_text).pack(anchor='w', padx=5)
            if self.last_drawing_status["error_message"]:
                tk.Label(status_frame, text=f"Details: {self.last_drawing_status['error_message']}", wraplength=400).pack(anchor='w', padx=5)

        test_z_frame = tk.Frame(self.main_frame, pady=5)
        test_z_frame.pack(pady=5)

        tk.Label(test_z_frame, text="Test / Drawing Z-Coordinate:").pack(side=tk.LEFT, padx=5)
        test_z_entry = tk.Entry(test_z_frame, textvariable=self.test_z_var, width=10)
        test_z_entry.pack(side=tk.LEFT)
        
        self.send_z_button = tk.Button(test_z_frame, text="Send to (0, 0, Z)", command=self.send_to_test_z_action)
        self.send_z_button.pack(side=tk.LEFT, padx=10)

        test_buttons_frame = tk.Frame(self.main_frame)
        test_buttons_frame.pack(pady=5)

        self.safe_center_button = tk.Button(test_buttons_frame, text="Go to Safe Center", command=self.send_to_safe_center_action, width=20)
        self.safe_center_button.pack(side=tk.LEFT, padx=5)

        self.test_workspace_button = tk.Button(test_buttons_frame, text="Test Workspace", command=self.test_workspace_action, width=20)
        self.test_workspace_button.pack(side=tk.LEFT, padx=5)

        tk.Button(self.main_frame, text="Capture Image to Draw",
                  command=self.capture_image_page, width=30).pack(pady=5)
        tk.Button(self.main_frame, text="Input Image to Draw",
                  command=self.input_image_page, width=30).pack(pady=5)
        
        tk.Button(self.main_frame, text="Disconnect",
                  command=self.close_and_return_main, width=30).pack(pady=5)

    def send_to_test_z_action(self):
        try:
            test_z = float(self.test_z_var.get())
        except ValueError:
            messagebox.showerror("Invalid Input", "The Z-coordinate must be a valid number.")
            return

        if self.send_z_button and self.send_z_button.winfo_exists():
            self.send_z_button.config(state=tk.DISABLED)
        # Standardized to (X, Y, Z)
        threading.Thread(target=self._send_command_sequence_thread, args=([(0.0, 0.0, test_z)], self.send_z_button), daemon=True).start()

    def send_to_safe_center_action(self):
        safe_z = 6 * PEN_DOWN_Z
        
        if hasattr(self, 'safe_center_button') and self.safe_center_button.winfo_exists():
            self.safe_center_button.config(state=tk.DISABLED)
        
        # Standardized to (X, Y, Z)
        logging.info(f"Sending robot to safe center (0, 0, {safe_z})")
        threading.Thread(target=self._send_command_sequence_thread, args=([(0, 0, safe_z)], self.safe_center_button), daemon=True).start()

    def test_workspace_action(self):
        """Sends the robot on a path to outline the workspace corners."""
        try:
            test_z = float(self.test_z_var.get())
        except ValueError:
            messagebox.showerror("Invalid Input", "The Z-coordinate for testing must be a valid number.")
            return

        if hasattr(self, 'test_workspace_button') and self.test_workspace_button.winfo_exists():
            self.test_workspace_button.config(state=tk.DISABLED)

        pen_up_z = - 1.3 * test_z
        
        if pen_up_z == 0:
            pen_up_z = -3

        # Standardized to (X, Y, Z)
        workspace_path = [
            (0,0, test_z),
            (50, 50, test_z),
            (50, -50, test_z),
            (-50, -50, test_z),
            (-50, 50, test_z),
            (0,0, test_z),
            (0, 0, pen_up_z)
        ]
        
        logging.info("Starting workspace test...")
        
        threading.Thread(target=self._send_command_sequence_thread, args=(workspace_path, self.test_workspace_button), daemon=True).start()

    def _send_command_sequence_thread(self, commands: List[Tuple], button_to_re_enable: tk.Button):
        """Thread worker to send a sequence of commands, one by one, using the new byte protocol."""
        original_text = button_to_re_enable.cget("text")
        self.window.after(0, lambda: button_to_re_enable.config(text="Moving..."))

        # Standardized to (X, Y, Z)
        for i, (x, y, z) in enumerate(commands):
            if self.cancel_requested:
                logging.info("Test sequence cancelled.")
                break
            
            logging.info(f"Sending command {i+1}/{len(commands)}: ({x:.2f}, {y:.2f}, {z:.2f})")
            # Standardized to pack (X, Y, Z)
            byte_data = struct.pack('!fff', x, y, z)
            
            if self.send_message_internal(byte_data):
                # response_r = self.receive_message_internal(timeout=5.0)
                # if response_r == "R":
                #     logging.info("Received 'R' (Ready) from robot.")
                    response_d = self.receive_message_internal(timeout=None)
                    if response_d == "D":
                        logging.info("Received 'D' (Done) from robot.")
                    else:
                        error_msg = f"Robot did not confirm completion (D) for command {i+1}. Got: '{response_d}'"
                        logging.error(error_msg)
                        self.window.after(0, lambda: messagebox.showerror("Test Failed", error_msg))
                        break
                # else:
                #     error_msg = f"Robot did not confirm receipt (R) for command {i+1}. Got: '{response_r}'"
                #     logging.error(error_msg)
                #     self.window.after(0, lambda: messagebox.showerror("Test Failed", error_msg))
                #     break
            else:
                self.window.after(0, lambda: messagebox.showerror("Connection Error", "Failed to send test command. Connection may be lost."))
                break
        
        if button_to_re_enable and button_to_re_enable.winfo_exists():
            self.window.after(0, lambda: button_to_re_enable.config(state=tk.NORMAL, text=original_text))
        logging.info(f"Sequence '{original_text}' finished.")


    def capture_image_page(self):
        self.clear_frame()
        tk.Label(self.main_frame, text="Camera View", font=("Arial", 16)).pack(pady=5)

        self.camera_frame_label = tk.Label(self.main_frame)
        self.camera_frame_label.pack(pady=10)

        button_frame = tk.Frame(self.main_frame)
        button_frame.pack(pady=5)

        self.capture_button = tk.Button(button_frame, text="Capture (S)", command=self.capture_action)
        self.capture_button.pack(side=tk.LEFT, padx=5)
        self.camera_back_button = tk.Button(button_frame, text="Back", command=self.stop_camera_and_go_back)
        self.camera_back_button.pack(side=tk.LEFT, padx=5)

        self.window.bind('s', self.capture_action_event)
        self.window.bind('S', self.capture_action_event)

        self.start_camera_feed()

    def start_camera_feed(self):
        if self.camera_running: return

        try:
            self.cap = cv2.VideoCapture(0)
            if not self.cap.isOpened():
                messagebox.showerror("Camera Error", "Could not open camera.")
                self.stop_camera_and_go_back()
                return
            self.camera_running = True
            self._update_camera_frame()
        except Exception as e:
            messagebox.showerror("Camera Error", f"Error initializing camera: {e}")
            self.stop_camera_and_go_back()

    def _update_camera_frame(self):
        if not self.camera_running or not self.cap:
            return

        ret, frame = self.cap.read()
        if ret:
            cv_image = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            pil_image = Image.fromarray(cv_image)
            imgtk = ImageTk.PhotoImage(image=pil_image)

            if self.camera_frame_label:
                self.camera_frame_label.imgtk = imgtk
                self.camera_frame_label.configure(image=imgtk)
        else:
            logging.warning("Failed to grab frame from camera.")

        if self.camera_running:
            self.window.after(30, self._update_camera_frame)

    def stop_camera_feed(self):
        self.camera_running = False
        time.sleep(0.1)
        if self.cap:
            self.cap.release()
            self.cap = None

    def stop_camera_and_go_back(self):
        self.stop_camera_feed()
        self.window.unbind('s')
        self.window.unbind('S')
        self.drawing_options_page()

    def capture_action_event(self, event=None):
        self.capture_action()

    def capture_action(self):
        if not self.camera_running or not self.cap:
            messagebox.showwarning("Capture Error", "Camera not running.")
            return

        ret, frame = self.cap.read()
        self.stop_camera_feed()
        self.window.unbind('s')
        self.window.unbind('S')

        if ret:
            try:
                os.makedirs(DATA_DIR, exist_ok=True)
                cv2.imwrite(TMP_CAPTURE_PATH, frame)
                logging.info(f"Image captured and saved to {TMP_CAPTURE_PATH}")
                self.current_image_path = TMP_CAPTURE_PATH
                self.show_threshold_options(self.current_image_path)
            except Exception as e:
                messagebox.showerror("Save Error", f"Could not save captured image: {e}")
                self.drawing_options_page()
        else:
            messagebox.showerror("Capture Error", "Failed to capture frame from camera.")
            self.drawing_options_page()

    def input_image_page(self):
        self.clear_frame()
        tk.Label(self.main_frame, text="Input Image to Draw", font=("Arial", 16)).pack(pady=10)

        entry_frame = tk.Frame(self.main_frame)
        entry_frame.pack(pady=5, fill='x', padx=10)
        tk.Label(entry_frame, text="Image Path:").pack(side=tk.LEFT)
        self.image_path_var = tk.StringVar()
        path_entry = tk.Entry(entry_frame, textvariable=self.image_path_var, width=50)
        path_entry.pack(side=tk.LEFT, fill='x', expand=True, padx=5)
        tk.Button(entry_frame, text="Browse...", command=self.browse_image_file).pack(side=tk.LEFT)

        tk.Button(self.main_frame, text="Process Image", command=self.process_input_image, width=20).pack(pady=10)
        tk.Button(self.main_frame, text="Back", command=self.drawing_options_page, width=20).pack(pady=10)

    def browse_image_file(self):
        filepath = filedialog.askopenfilename(
            title="Select Image to Draw",
            filetypes=[("Image Files", "*.png *.jpg *.jpeg *.bmp *.gif"), ("All Files", "*.*")]
        )
        if filepath:
            self.image_path_var.set(filepath)

    def process_input_image(self):
        filepath = self.image_path_var.get()
        if not filepath or not os.path.isfile(filepath):
            messagebox.showerror("Error", f"Invalid or non-existent file path:\n{filepath}")
            return
        self.current_image_path = filepath
        self.show_threshold_options(self.current_image_path)

    def show_threshold_options(self, image_path):
        self.clear_frame()
        tk.Label(self.main_frame, text="Select Drawing Style (Thresholds)", font=("Arial", 16)).pack(pady=10)

        self.threshold_options_data = {}
        self.selected_threshold_option = tk.StringVar(value=None)
        self.preview_label = tk.Label(self.main_frame)
        self.preview_label.pack(pady=5)

        options_frame = tk.Frame(self.main_frame)
        options_frame.pack(pady=5)

        loading_label = tk.Label(options_frame, text="Processing options...")
        loading_label.pack()
        self.window.update()

        try:
            pen_down_z = float(self.test_z_var.get())
            logging.info(f"Using custom pen down Z for drawing path generation: {pen_down_z}")
        except (ValueError, tk.TclError):
            logging.warning("Invalid or no custom Z value found, using default.")
            pen_down_z = PEN_DOWN_Z

        threading.Thread(target=self._process_threshold_options_thread, args=(image_path, options_frame, loading_label, pen_down_z), daemon=True).start()

    def _process_threshold_options_thread(self, image_path, options_frame, loading_label, pen_down_z):
        results = {}
        preview_paths = {}

        for i, (label, t1, t2) in enumerate(THRESHOLD_OPTIONS):
            logging.info(f"Processing option: {label} (t1={t1}, t2={t2})")
            preview_path = TMP_EDGE_OUTPUT_PATH.format(i)
            contours_xy, w, h = image_to_contours_internal(image_path, t1, t2, save_edge_path=preview_path)

            if contours_xy is None or w == 0 or h == 0:
                logging.warning(f"Failed to process contours for option {label}")
                results[label] = None
                preview_paths[label] = None
                continue

            commands = create_drawing_paths(contours_xy, w, h, pen_down_z, optimize_paths=True)
            if commands:
                num_commands = len(commands)
                est_time_sec = num_commands * TIME_ESTIMATE_FACTOR
                est_time_min = est_time_sec / 60
                results[label] = {
                    "commands": commands,
                    "count": num_commands,
                    "time_str": f"{est_time_min:.1f} min",
                    "t1": t1,
                    "t2": t2
                }
                preview_paths[label] = preview_path if os.path.exists(preview_path) else None
            else:
                results[label] = None
                preview_paths[label] = None
                logging.warning(f"No commands generated for option {label}")

        self.window.after(0, lambda: self._display_threshold_options(options_frame, loading_label, results, preview_paths))

    def _display_threshold_options(self, options_frame, loading_label, results, preview_paths):
        loading_label.destroy()

        self.threshold_options_data = results
        self.edge_preview_paths = preview_paths

        default_selected = False
        for i, (label, t1, t2) in enumerate(THRESHOLD_OPTIONS):
            option_data = results.get(label)
            if option_data:
                count = option_data["count"]
                time_str = option_data["time_str"]
                radio_text = f"{label} (t1={t1}, t2={t2}) - Cmds: {count}, Est: {time_str}"
                rb = tk.Radiobutton(
                    options_frame,
                    text=radio_text,
                    variable=self.selected_threshold_option,
                    value=label,
                    command=lambda l=label: self.show_edge_preview(l)
                )
                rb.pack(anchor='w')
                if not default_selected:
                    self.selected_threshold_option.set(label)
                    self.show_edge_preview(label)
                    default_selected = True
            else:
                tk.Label(options_frame, text=f"{label} (t1={t1}, t2={t2}) - No drawing generated", fg="gray").pack(anchor='w')

        button_frame = tk.Frame(self.main_frame)
        button_frame.pack(pady=10)
        tk.Button(button_frame, text="Confirm and Draw", command=self.confirm_and_start_drawing, width=20).pack(side=tk.LEFT, padx=5)
        tk.Button(button_frame, text="Save Points to File", command=self.save_points_to_file, width=20).pack(side=tk.LEFT, padx=5)
        tk.Button(button_frame, text="Back", command=self.drawing_options_page, width=20).pack(side=tk.LEFT, padx=5)

    def save_points_to_file(self):
        """Saves the generated drawing commands for the selected option to a text file."""
        selected_label = self.selected_threshold_option.get()
        if not selected_label:
            messagebox.showwarning("Selection Needed", "Please select a drawing style option first.")
            return

        option_data = self.threshold_options_data.get(selected_label)
        if not option_data or not option_data.get("commands"):
            messagebox.showerror("Error", "Selected option has no drawing commands to save.")
            return

        commands = option_data["commands"]
        
        filepath = filedialog.asksaveasfilename(
            title="Save Drawing Points",
            defaultextension=".txt",
            filetypes=[("Text Files", "*.txt"), ("All Files", "*.*")],
            initialfile="drawing_points.txt"
        )

        if not filepath:
            # User cancelled the save dialog
            return

        try:
            with open(filepath, 'w') as f:
                # Format as a tuple of tuples: ((x,y,z),(x,y,z),...)
                points_str = ",".join([f"({x:.2f},{y:.2f},{z:.2f})" for x, y, z in commands])
                f.write(f"({points_str})")
            
            messagebox.showinfo("Success", f"Drawing points successfully saved to:\n{filepath}")
        except Exception as e:
            messagebox.showerror("Save Error", f"Could not save the file.\nError: {e}")

    def show_edge_preview(self, option_label):
        preview_path = self.edge_preview_paths.get(option_label)
        if preview_path and os.path.exists(preview_path):
            try:
                img = Image.open(preview_path)
                img.thumbnail((300, 300))
                imgtk = ImageTk.PhotoImage(image=img)
                self.preview_label.imgtk = imgtk
                self.preview_label.configure(image=imgtk)
            except Exception as e:
                logging.error(f"Error loading preview image {preview_path}: {e}")
                self.preview_label.configure(image=None, text="Preview error")
        else:
            self.preview_label.configure(image=None, text="No Preview")

    def confirm_and_start_drawing(self):
        selected_label = self.selected_threshold_option.get()
        if not selected_label:
            messagebox.showwarning("Selection Needed", "Please select a drawing style option.")
            return

        option_data = self.threshold_options_data.get(selected_label)
        if not option_data or not option_data.get("commands"):
            messagebox.showerror("Error", "Selected option has no drawing commands.")
            return

        self.selected_commands = option_data["commands"]

        if not self.drawing_in_progress:
            self.drawing_in_progress = True
            self.cancel_requested = False
            self.resume_needed = False
            self.pause_event.set()
            
            try:
                pen_down_z = float(self.test_z_var.get())
            except (ValueError, tk.TclError):
                pen_down_z = PEN_DOWN_Z

            full_command_list = self.selected_commands + create_signature_commands(SIGNATURE_WAYPOINTS, pen_down_z)
            
            # --- ETA Calculation ---
            self.total_estimated_time = len(full_command_list) * TIME_ESTIMATE_FACTOR
            self.drawing_start_time = time.time()
            self.total_paused_time = 0
            self.pause_start_time = 0
            
            threading.Thread(target=self.run_drawing_loop, args=(full_command_list,), daemon=True).start()
            self.show_drawing_progress_page(len(full_command_list))
        else:
            messagebox.showwarning("Busy", "Drawing already in progress.")

    def show_drawing_progress_page(self, total_commands, current_progress=0):
        self.clear_frame()
        tk.Label(self.main_frame, text="Drawing in Progress...", font=("Arial", 16)).pack(pady=10)

        self.status_label = tk.Label(self.main_frame, textvariable=self.progress_text_var)
        self.status_label.pack(pady=5)

        self.progress_bar = ttk.Progressbar(self.main_frame, orient="horizontal", length=300, mode="determinate", maximum=total_commands, value=current_progress)
        self.progress_bar.pack(pady=10)

        controls_frame = tk.Frame(self.main_frame)
        controls_frame.pack(pady=5)

        self.pause_resume_button = tk.Button(controls_frame, text="Pause", command=self.toggle_pause_resume, width=15)
        self.pause_resume_button.pack(side=tk.LEFT, padx=5)
        
        self.cancel_button = tk.Button(controls_frame, text="Cancel Drawing", command=self.request_cancel_drawing, width=15)
        self.cancel_button.pack(side=tk.LEFT, padx=5)

        # Start the ETA update loop
        self.update_drawing_status(current_progress, total_commands)
        self._update_eta_countdown()


    def _update_eta_countdown(self):
        """Periodically updates the ETA label with a dynamic estimate."""
        if not self.drawing_in_progress:
            return

        completed_cmds = self.progress_bar['value']
        total_cmds = self.progress_bar['maximum']
        
        remaining_time = 0
        
        # Only calculate dynamic ETA after a few commands have completed for stability
        if completed_cmds > 5:
            # Calculate total time spent actively drawing (excluding pauses)
            active_drawing_time = (time.time() - self.drawing_start_time) - self.total_paused_time
            avg_time_per_cmd = active_drawing_time / completed_cmds
            remaining_cmds = total_cmds - completed_cmds
            remaining_time = remaining_cmds * avg_time_per_cmd
        else:
            # For the beginning, use the initial static estimate
            elapsed_time = (time.time() - self.drawing_start_time) - self.total_paused_time
            initial_total_time = total_cmds * TIME_ESTIMATE_FACTOR
            remaining_time = initial_total_time - elapsed_time

        if remaining_time < 0:
            remaining_time = 0

        mins, secs = divmod(int(remaining_time), 60)
        time_str = f"{mins:02d}:{secs:02d}"
        
        # Update the full progress text
        self.progress_text_var.set(f"Sent {completed_cmds} / {total_cmds} commands | ETA: {time_str}")

        # Schedule the next update
        self.eta_update_id = self.window.after(1000, self._update_eta_countdown)


    def toggle_pause_resume(self):
        if self.pause_event.is_set():
            # --- PAUSING ---
            self.pause_event.clear()
            logging.info("Drawing paused by user.")
            if self.pause_resume_button and self.pause_resume_button.winfo_exists():
                self.pause_resume_button.config(text="Resume")
            
            # Record when the pause started
            self.pause_start_time = time.time()
            
            # Stop the timer when paused
            if self.eta_update_id:
                self.window.after_cancel(self.eta_update_id)
                self.eta_update_id = None
        else:
            # --- RESUMING ---
            self.pause_event.set()
            logging.info("Drawing resumed by user.")
            if self.pause_resume_button and self.pause_resume_button.winfo_exists():
                self.pause_resume_button.config(text="Pause")
            
            # Add the duration of the pause to the total paused time
            if self.pause_start_time > 0:
                paused_duration = time.time() - self.pause_start_time
                self.total_paused_time += paused_duration
                self.pause_start_time = 0 # Reset for next pause

            # Restart the timer when resumed
            self._update_eta_countdown()

    def update_drawing_status(self, current_command_index, total_commands):
        """Updates the progress bar. The label is handled by the ETA loop."""
        if self.progress_bar and self.progress_bar.winfo_exists():
            self.progress_bar['value'] = current_command_index
        
        # The text variable is now updated entirely by the _update_eta_countdown loop
        # to prevent race conditions and keep the display smooth.

    def request_cancel_drawing(self):
        if self.drawing_in_progress:
            logging.info("Cancel requested by user.")
            self.cancel_requested = True
            self.pause_event.set() # Unblock the drawing loop so it can see the flag
            if self.cancel_button and self.cancel_button.winfo_exists():
                self.cancel_button.config(text="Cancelling...", state=tk.DISABLED)
            if self.pause_resume_button and self.pause_resume_button.winfo_exists():
                self.pause_resume_button.config(state=tk.DISABLED)
            if self.status_label and self.status_label.winfo_exists():
                self.progress_text_var.set("Cancellation requested...")

    def _send_final_position_and_cleanup(self, success_message, failure_message):
        self.drawing_in_progress = False # Stop the ETA loop
        logging.info("Attempting to move robot to final position.")
        # Standardized to (X, Y, Z)
        final_x, final_y, final_z = FINAL_ROBOT_POSITION
        byte_data = struct.pack('!fff', final_x, final_y, final_z)

        move_ok = False
        if self.connected and self.socket:
            if self.send_message_internal(byte_data):
                # response_r_final = self.receive_message_internal(timeout=None)
                # if response_r_final == "R":
                    response_d_final = self.receive_message_internal(timeout=None)
                    if response_d_final == "D":
                        logging.info("Robot reached final position.")
                        move_ok = True
                    else:
                        logging.error(f"Robot didn't confirm final move completion (D), got '{response_d_final}'")
                # else:
                #     logging.error(f"Robot didn't confirm final move receipt (R), got '{response_r_final}'")
            else:
                logging.error("Failed to send final position command.")

        final_status = ""
        if move_ok:
            final_status = f"{success_message} Robot at final position."
        else:
            final_status = f"{failure_message} Failed to reach final position."

        self.last_drawing_status["status"] = success_message
        self.last_drawing_status["error_message"] = "" if move_ok else "Failed to reach final position."

        self.window.after(0, lambda fs=final_status: self.update_final_status(fs))

        self.selected_commands = None
        self.cancel_requested = False
        if not self.resume_needed:
            self.resume_commands = None
            self.resume_total_original_commands = 0
            self.resume_start_index_global = 0

        self.window.after(2000, self.drawing_options_page)

    def update_final_status(self, message):
        if self.eta_update_id:
            self.window.after_cancel(self.eta_update_id)
            self.eta_update_id = None
        if self.status_label and self.status_label.winfo_exists():
            self.progress_text_var.set(message)
        if self.cancel_button and self.cancel_button.winfo_exists():
            self.cancel_button.pack_forget()
        if self.pause_resume_button and self.pause_resume_button.winfo_exists():
            self.pause_resume_button.pack_forget()

    def run_drawing_loop(self, commands_to_send: List[Tuple], start_index=0):
        """Sends drawing commands one by one using the byte protocol."""
        total_commands = len(commands_to_send)
        
        if start_index > 0:
            self.window.after(0, lambda: self.show_drawing_progress_page(total_commands, start_index))
        
        try:
            # Standardized to (X, Y, Z)
            for i, (x, y, z) in enumerate(commands_to_send[start_index:]):
                self.pause_event.wait()
                if self.cancel_requested:
                    logging.info("Cancellation detected in drawing loop.")
                    # Call the cleanup function to move to a final safe position and reset the UI
                    self._send_final_position_and_cleanup("Drawing Cancelled.", "Drawing Cancelled.")
                    return

                current_command_global_index = start_index + i
                
                # Standardized to pack (X, Y, Z)
                byte_data = struct.pack('!fff', x, y, z)

                if not self.send_message_internal(byte_data):
                    logging.error(f"Connection lost while sending command. Preparing to resume.")
                    self.drawing_in_progress = False # Stop ETA loop
                    self.resume_needed = True
                    self.resume_commands = commands_to_send
                    self.resume_start_index_global = current_command_global_index
                    return

                # response_r = self.receive_message_internal(timeout=10.0)
                # if response_r != "R":
                #     logging.error(f"Robot did not confirm receipt (R), got '{response_r}'.")
                #     self.drawing_in_progress = False
                #     return
                
                response_d = self.receive_message_internal(timeout=None)
                if response_d != "D":
                    logging.error(f"Robot did not confirm completion (D), got '{response_d}'.")
                    self.drawing_in_progress = False
                    return
                
                # Update the progress bar value. The label text is handled by the ETA loop.
                self.window.after(0, lambda p=current_command_global_index + 1: self.update_drawing_status(p, total_commands))

            logging.info("All drawing commands sent successfully.")
            self._send_final_position_and_cleanup("Drawing Complete.", "Drawing Complete.")

        except Exception as e:
            logging.error(f"Unexpected error during drawing process: {e}", exc_info=True)
            self.drawing_in_progress = False

    def send_message_internal(self, message: bytes) -> bool:
        """ Sends byte data without triggering GUI popups on error. Returns success status. """
        if not self.connected or not self.socket: return False
        try:
            self.socket.sendall(message)
            return True
        except (socket.error, ConnectionResetError, BrokenPipeError, socket.timeout) as e:
            logging.error(f"Send error (internal): {e}")
            self.handle_connection_loss()
            return False

    def receive_message_internal(self, timeout=None) -> Optional[str]:
        if not self.connected or not self.socket: return None
        try:
            self.socket.settimeout(timeout)
            data = self.socket.recv(1024)
            self.socket.settimeout(None)
            if not data:
                logging.warning("Receive error (internal): Connection closed by peer.")
                self.handle_connection_loss()
                return None
            decoded_data = data.decode('utf-8').strip()
            return decoded_data
        except socket.timeout:
            logging.error(f"Timeout receiving message (internal)")
            return None
        except (socket.error, ConnectionResetError, BrokenPipeError) as e:
            logging.error(f"Receive error (internal): {e}")
            self.handle_connection_loss()
            return None

    def handle_connection_loss(self):
        logging.warning("Connection lost detected.")
        was_connected = self.connected
        self.close_socket()
        if was_connected and not self.drawing_in_progress and not self.resume_needed:
            self.window.after(0, lambda: messagebox.showinfo("Connection Lost", "Robot connection lost."))

    def establish_connection(self):
        if hasattr(self, 'connect_button') and self.connect_button.winfo_exists(): self.connect_button.config(state=tk.DISABLED)
        if hasattr(self, 'reconnect_button') and self.reconnect_button.winfo_exists(): self.reconnect_button.config(state=tk.DISABLED)

        host, port = (SIMULATION_HOST, SIMULATION_PORT) if self.connection_var.get() == "simulation" else (REAL_ROBOT_HOST, REAL_ROBOT_PORT)

        def connection_attempt():
            try:
                self.close_socket()
                self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                self.socket.settimeout(5)
                self.socket.connect((host, port))
                self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                self.socket.settimeout(None)
                logging.info(f"Connected to {host}:{port}")
                self.connected = True
                self.window.after(0, lambda: self.handle_connection_result(True))
            except (socket.error, socket.timeout, ConnectionRefusedError) as e:
                logging.error(f"Connection error: {e}")
                self.connected = False
                self.close_socket()
                self.window.after(0, lambda: self.handle_connection_result(False))
        threading.Thread(target=connection_attempt, daemon=True).start()

    def handle_connection_result(self, connected):
        if hasattr(self, 'connect_button') and self.connect_button.winfo_exists():
            self.connect_button.config(state=tk.NORMAL)
        if hasattr(self, 'reconnect_button') and self.reconnect_button.winfo_exists():
            self.reconnect_button.config(state=tk.NORMAL)

        if connected:
            self.connection_established = True
            if self.resume_needed and self.resume_commands is not None:
                logging.info("Reconnection successful. Preparing to resume drawing.")
                self.move_to_final_before_resume()
            else:
                self.drawing_options_page()
        else:
            if self.resume_needed:
                messagebox.showerror("Reconnection Failed", "Failed to reconnect. Cannot resume the previous drawing.")
                self.resume_needed = False
                self.resume_commands = None
                self.resume_total_original_commands = 0
                self.resume_start_index_global = 0
                self.last_drawing_status["status"] = "Resume Failed"
                self.last_drawing_status["error_message"] = "Could not reconnect to robot."
                self.drawing_options_page()
            else:
                messagebox.showerror("Connection Failed", "Failed to establish connection.")

    def move_to_final_before_resume(self):
        def move_and_resume_thread():
            logging.info("Moving robot to FINAL_ROBOT_POSITION before resuming...")
            self.show_drawing_progress_page(self.resume_total_original_commands, self.resume_start_index_global)

            # Standardized to (X, Y, Z)
            final_x, final_y, final_z = FINAL_ROBOT_POSITION
            byte_data = struct.pack('!fff', final_x, final_y, final_z)
            move_ok = False
            if self.connected and self.socket:
                if self.send_message_internal(byte_data):
                    # response_r = self.receive_message_internal(timeout=5.0)
                    # if response_r == "R":
                        response_d = self.receive_message_internal(timeout=5.0)
                        if response_d == "D":
                            logging.info("Robot reached FINAL_ROBOT_POSITION.")
                            move_ok = True
                        else: logging.error("Failed to get 'D' confirmation for pre-resume move.")
                    # else: logging.error("Failed to get 'R' confirmation for pre-resume move.")
                else: logging.error("Failed to send pre-resume move command.")

            if move_ok:
                logging.info(f"Starting resume from command index {self.resume_start_index_global}")
                self.drawing_in_progress = True
                self.cancel_requested = False
                self.pause_event.set()
                self.run_drawing_loop(self.resume_commands, self.resume_start_index_global)
            else:
                error_msg = "Failed to move robot to safe resume position."
                logging.error(error_msg + " Cannot resume automatically, but allowing retry.")
                self.last_drawing_status["status"] = "Resume Failed (Pre-move)"
                self.last_drawing_status["error_message"] = error_msg
                self.window.after(0, lambda: messagebox.showwarning("Resume Warning", error_msg + "\nConnection might be unstable. You can try 'Reconnect & Resume' again."))
                self.drawing_in_progress = False
                self.window.after(1000, self.connection_setup_page)

        threading.Thread(target=move_and_resume_thread, daemon=True).start()

    def close_socket(self):
        if self.socket:
            try:
                self.socket.shutdown(socket.SHUT_RDWR)
            except (socket.error, OSError): pass
            finally:
                try: self.socket.close()
                except (socket.error, OSError): pass
                self.socket = None
                logging.info("Socket closed")
        self.connected = False
        self.connection_established = False

    def close_and_return_main(self):
        self.pause_event.set()
        self.close_socket()
        self.resume_needed = False
        self.resume_commands = None
        self.resume_total_original_commands = 0
        self.resume_start_index_global = 0
        self.main_page()

    def clear_frame(self):
        if self.camera_running:
            self.stop_camera_feed()
        # Cancel any pending ETA update
        if self.eta_update_id:
            self.window.after_cancel(self.eta_update_id)
            self.eta_update_id = None
        for widget in self.main_frame.winfo_children():
            widget.destroy()
        self.camera_frame_label = None
        self.capture_button = None
        self.camera_back_button = None
        self.progress_bar = None
        self.status_label = None
        self.cancel_button = None
        self.connect_button = None
        self.reconnect_button = None
        self.preview_label = None
        self.pause_resume_button = None

    def on_window_close(self):
        logging.info("Window close requested.")
        self.cancel_requested = True
        self.drawing_in_progress = False # Stop ETA loop
        self.pause_event.set()
        self.stop_camera_feed()
        self.close_socket()
        time.sleep(0.2)
        self.window.destroy()

if __name__ == "__main__":
    os.makedirs(DATA_DIR, exist_ok=True)
    app = RUNME_GUI()
    app.window.protocol("WM_DELETE_WINDOW", app.on_window_close)
    app.window.mainloop()

--- END OF FILE: testing/main_without_R.py ---
--- START OF FILE: testing/test_main_gui.py ---
import tkinter as tk
from tkinter import messagebox, filedialog, ttk # Added ttk for progress bar
import os
import threading
import time
import logging
import socket
from concurrent.futures import ThreadPoolExecutor
from typing import List, Tuple, Optional
import cv2 # <-- Added
import numpy as np # <-- Added (likely already implicitly used by cv2)
import math
from PIL import Image, ImageTk # <-- Added
# Consider adding tkinterdnd2 for drag-and-drop later if needed
# import tkinterdnd2

# --- Drawing Logic Imports ---
# Assuming the drawing functions are defined below or imported
# (image_to_contours, scale_point_to_a4, create_drawing_paths, calculate_distance)

# Configure logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")

# --- Constants (Consolidated) ---
SCRIPT_DIR = os.getenv("SCRIPT_DIR", ".") # Default to current dir if not set
DATA_DIR = os.getenv("DATA_DIR", ".") # Default to current dir

# TMP_POSITION_FILE = os.path.join(DATA_DIR, "Tmp_position.txt") # Likely not needed for drawing
TMP_CAPTURE_PATH = os.path.join(DATA_DIR, "temp_capture.png") # For captured image
TMP_EDGE_OUTPUT_PATH = os.path.join(DATA_DIR, "temp_edges_{}.png") # For edge previews

REAL_ROBOT_HOST = '192.168.125.1'
REAL_ROBOT_PORT = 1025
SIMULATION_HOST = '127.0.0.1'
SIMULATION_PORT = 55000

# Drawing Specific Constants (from provided code)
FINAL_ROBOT_POSITION = (0,-350, 0) # Use X, Z, Y format from previous examples
A4_WIDTH_MM = 190
A4_HEIGHT_MM = 277
PEN_UP_Z = -15
PEN_DOWN_Z = -7
MIN_CONTOUR_LENGTH_PX = 10

# Threshold options: (Label, threshold1, threshold2)
# THRESHOLD_OPTIONS = [
#     ("Detail", 25, 75),
#     ("Balanced", 50, 150),
#     ("Simple", 75, 200),
#     ("Minimal", 100, 250)
# ]

# 10 Threshold options for testing (if needed)
THRESHOLD_OPTIONS = [
    ("Option {}".format(i), i*10, i*20) for i in range(1, 11)
]

# Rough estimate for time per command (adjust based on observation)
TIME_ESTIMATE_FACTOR = 0.3 # seconds per command (very rough guess)

# --- Drawing Helper Function ---
def calculate_distance(p1, p2):
    """Calculates Euclidean distance between two points (x, y)."""
    # Add check for None or invalid input if necessary
    if p1 is None or p2 is None: return float('inf')
    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)

# --- Drawing Image Processing Functions ---
def image_to_contours_internal(image_path_or_array, threshold1, threshold2, save_edge_path=None):
    """
    Internal version: Convert image to contours using specific thresholds.
    Can accept a file path OR a pre-loaded cv2 image array.
    Does NOT print status messages.
    :param image_path_or_array: Path to the input image or numpy array (BGR or Grayscale).
    :param threshold1: Lower threshold for Canny edge detection.
    :param threshold2: Upper threshold for Canny edge detection.
    :param save_edge_path: Optional path to save the edge image for preview.
    :return: List of contours (pixel coordinates), image_width, image_height, or (None, 0, 0) on failure.
    """
    if isinstance(image_path_or_array, str):
        image = cv2.imread(image_path_or_array, cv2.IMREAD_GRAYSCALE)
    elif isinstance(image_path_or_array, np.ndarray):
        if len(image_path_or_array.shape) == 3: # BGR
             image = cv2.cvtColor(image_path_or_array, cv2.COLOR_BGR2GRAY)
        else: # Assuming already grayscale
             image = image_path_or_array
    else:
        logging.error("Invalid input type for image_to_contours_internal")
        return None, 0, 0

    if image is None:
        logging.error(f"Could not read or process image input.")
        return None, 0, 0

    image_height, image_width = image.shape[:2]
    if image_height == 0 or image_width == 0:
         logging.error("Invalid image dimensions.")
         return None, 0, 0

    blurred = cv2.GaussianBlur(image, (5, 5), 0)
    edges = cv2.Canny(blurred, threshold1, threshold2)

    if save_edge_path:
        try:
            cv2.imwrite(save_edge_path, edges)
        except Exception as e:
            logging.error(f"Failed to save edge image to {save_edge_path}: {e}")

    contours, hierarchy = cv2.findContours(edges, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)
    filtered_contours = [c for c in contours if cv2.arcLength(c, closed=False) > MIN_CONTOUR_LENGTH_PX]

    contours_xy = []
    for contour in filtered_contours:
        points = contour.squeeze().tolist()
        if not isinstance(points, list) or not points: continue # Skip empty squeezes
        if isinstance(points[0], int): # Handle single point contour
            points = [points]
        contours_xy.append([(p[0], p[1]) for p in points if isinstance(p, (list, tuple)) and len(p) == 2]) # Ensure points are valid pairs

    # Filter out empty contours that might result from the above processing
    contours_xy = [c for c in contours_xy if c]

    return contours_xy, image_width, image_height


def scale_point_to_a4(point_xy, image_width, image_height, scale_factor):
    """ Scales and transforms a single (x, y) pixel coordinate to centered A4 (mm). """
    x_pixel, y_pixel = point_xy
    center_x_pixel = image_width / 2
    center_y_pixel = image_height / 2
    x_centered_pixel = x_pixel - center_x_pixel
    y_centered_pixel = center_y_pixel - y_pixel # Invert y-axis
    x_mm = x_centered_pixel * scale_factor
    y_mm = y_centered_pixel * scale_factor
    return (x_mm, y_mm)

def create_drawing_paths(contours_xy, image_width, image_height, optimize_paths=True):
    """ Takes list of contours (pixel coordinates), scales them, creates drawing paths. """
    if not contours_xy or image_width <= 0 or image_height <= 0:
        return []

    scale_x = A4_WIDTH_MM / image_width
    scale_y = A4_HEIGHT_MM / image_height
    scale_factor = min(scale_x, scale_y)

    scaled_contours = []
    for contour in contours_xy:
        # Ensure contour is not empty before scaling
        if not contour: continue
        scaled_contour = [scale_point_to_a4(p, image_width, image_height, scale_factor) for p in contour]
        if len(scaled_contour) >= 2:
            scaled_contours.append(scaled_contour)
        elif len(scaled_contour) == 1 :
             # Handle single points - represent as a tiny segment back to itself?
             # This ensures it gets processed for pen down/up at least.
             scaled_contours.append([scaled_contour[0], scaled_contour[0]])


    if not scaled_contours:
        return []

    ordered_contours = []
    last_point = None # Keep track of the last point of the previously added contour
    if optimize_paths:
        remaining_contours = list(scaled_contours)
        # Find a starting contour (e.g., closest to origin, or just the first)
        # For simplicity, start with the first one if available.
        if remaining_contours:
             current_contour = remaining_contours.pop(0)
             ordered_contours.append(current_contour)
             last_point = current_contour[-1]

             while remaining_contours:
                 best_dist = float('inf')
                 best_idx = -1
                 best_reversed = False

                 for i, contour in enumerate(remaining_contours):
                     start_point = contour[0]
                     end_point = contour[-1]
                     dist_start = calculate_distance(last_point, start_point)
                     dist_end = calculate_distance(last_point, end_point)

                     if dist_start < best_dist:
                         best_dist = dist_start
                         best_idx = i
                         best_reversed = False
                     if dist_end < best_dist: # Check second condition independently
                         best_dist = dist_end
                         best_idx = i
                         best_reversed = True

                 if best_idx != -1:
                      next_contour = remaining_contours.pop(best_idx)
                      if best_reversed:
                          next_contour.reverse()
                      ordered_contours.append(next_contour)
                      last_point = next_contour[-1]
                 else:
                      # Should not happen if remaining_contours is not empty, but break just in case
                      logging.warning("Path optimization loop finished unexpectedly.")
                      break # Avoid infinite loop if something goes wrong
        scaled_contours = ordered_contours # Use the optimized order
        # logging.info(f"Optimized contour drawing order.") # Reduce noise
    else:
         # If not optimizing, just use the original order
         scaled_contours = [c for c in scaled_contours] # Ensure it's a list copy if needed


    robot_commands = []
    for contour in scaled_contours:
        if not contour: continue # Should not happen, but safe check
        start_point = contour[0]
        robot_commands.append((start_point[0], PEN_UP_Z, start_point[1]))
        robot_commands.append((start_point[0], PEN_DOWN_Z, start_point[1]))

        for i in range(len(contour) - 1):
            end_point = contour[i+1]
            # Avoid duplicate commands for single-point contours handled earlier
            if end_point != contour[i]:
                robot_commands.append((end_point[0], PEN_DOWN_Z, end_point[1]))

        final_point = contour[-1]
        robot_commands.append((final_point[0], PEN_UP_Z, final_point[1]))

    return robot_commands

class RUNME_GUI:
    """Main GUI application for the Robotics System."""

    def __init__(self):
        self.window = tk.Tk()
        self.window.title("Robotics Drawing GUI")
        self.main_frame = tk.Frame(self.window)
        self.main_frame.pack(pady=20, padx=20, fill="both", expand=True)

        # Connection related variables
        self.connection_var = tk.StringVar(value="simulation")
        self.socket = None
        self.connected = False
        self.connection_established = False
        # self.positions = [] # Removed, not used for drawing

        # Camera related variables
        self.cap = None
        self.camera_running = False
        self.camera_frame_label = None # Label to display camera feed
        self.capture_button = None
        self.camera_back_button = None

        # Drawing process related
        self.current_image_path = None # Path to the image being processed
        self.threshold_options_data = {} # Store commands for each threshold choice
        self.selected_commands = None
        self.drawing_in_progress = False
        self.progress_bar = None
        self.status_label = None

        self.main_page()

    # --- Page Navigation ---
    def main_page(self):
        """Main application page."""
        self.clear_frame()
        tk.Label(self.main_frame, text="Robotics Drawing System", font=("Arial", 16)).pack(pady=10)
        tk.Button(self.main_frame, text="Setup Connection & Draw",
                  command=self.connection_setup_page, width=30).pack(pady=5)
        # tk.Button(self.main_frame, text="Camera Calibration", # Keep if needed
        #           command=self.calibration_page, width=30).pack(pady=5)
        tk.Button(self.main_frame, text="Exit",
                  command=self.on_window_close, width=30).pack(pady=5) # Call proper close handler

    def connection_setup_page(self):
        """Page for setting up robot connection."""
        # Simplified - remove radio buttons if only one target is needed often
        # Or keep as is
        self.clear_frame()
        tk.Label(self.main_frame, text="Robot Connection Setup", font=("Arial", 16)).pack(pady=10)
        # ... (Radio buttons and connection frame as before) ...
        connection_frame = tk.Frame(self.main_frame)
        connection_frame.pack(pady=10)
        tk.Radiobutton(connection_frame, text=f"Simulation: {SIMULATION_HOST}:{SIMULATION_PORT}",
                       variable=self.connection_var, value="simulation").pack(anchor='w')
        tk.Radiobutton(connection_frame, text=f"Real Robot: {REAL_ROBOT_HOST}:{REAL_ROBOT_PORT}",
                       variable=self.connection_var, value="real").pack(anchor='w')

        self.connect_button = tk.Button(self.main_frame, text="Connect", command=self.establish_connection, width=20)
        self.connect_button.pack(pady=5)
        tk.Button(self.main_frame, text="Back", command=self.main_page, width=20).pack(pady=5) # Go back to main page


    def drawing_options_page(self):
        """Page shown after successful connection."""
        if not self.connection_established:
            messagebox.showerror("Connection Required", "Please establish connection first.")
            self.connection_setup_page()
            return

        self.clear_frame()
        tk.Label(self.main_frame, text="Robot Drawing Options", font=("Arial", 16)).pack(pady=10)
        conn_type = "Simulation" if self.connection_var.get() == "simulation" else "Real Robot"
        tk.Label(self.main_frame, text=f"Connected to: {conn_type}", fg="green").pack(pady=5)

        tk.Button(self.main_frame, text="Capture Image to Draw",
                  command=self.capture_image_page, width=30).pack(pady=5) # Changed command
        tk.Button(self.main_frame, text="Input Image to Draw",
                  command=self.input_image_page, width=30).pack(pady=5) # Changed command
        tk.Button(self.main_frame, text="Disconnect",
                  command=self.close_and_return_main, width=30).pack(pady=5)

    # --- Capture Image Workflow ---
    def capture_image_page(self):
        """Opens camera view for capturing."""
        self.clear_frame()
        tk.Label(self.main_frame, text="Camera View", font=("Arial", 16)).pack(pady=5)

        self.camera_frame_label = tk.Label(self.main_frame)
        self.camera_frame_label.pack(pady=10)

        button_frame = tk.Frame(self.main_frame)
        button_frame.pack(pady=5)

        self.capture_button = tk.Button(button_frame, text="Capture (S)", command=self.capture_action)
        self.capture_button.pack(side=tk.LEFT, padx=5)
        self.camera_back_button = tk.Button(button_frame, text="Back", command=self.stop_camera_and_go_back)
        self.camera_back_button.pack(side=tk.LEFT, padx=5)

        # Bind 's' key
        self.window.bind('s', self.capture_action_event)
        self.window.bind('S', self.capture_action_event) # Also capital S

        self.start_camera_feed()

    def start_camera_feed(self):
        """Starts displaying the camera feed."""
        if self.camera_running: return # Already running

        try:
            self.cap = cv2.VideoCapture(0) # Use default camera
            if not self.cap.isOpened():
                messagebox.showerror("Camera Error", "Could not open camera.")
                self.stop_camera_and_go_back()
                return
            self.camera_running = True
            self._update_camera_frame() # Start the update loop
        except Exception as e:
             messagebox.showerror("Camera Error", f"Error initializing camera: {e}")
             self.stop_camera_and_go_back()


    def _update_camera_frame(self):
        """Internal method to continuously update the camera feed label."""
        if not self.camera_running or not self.cap:
             return

        ret, frame = self.cap.read()
        if ret:
            # Convert frame for Tkinter
            cv_image = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            pil_image = Image.fromarray(cv_image)
            # Resize image to fit nicely (optional)
            # aspect_ratio = pil_image.width / pil_image.height
            # new_height = 300
            # new_width = int(aspect_ratio * new_height)
            # pil_image = pil_image.resize((new_width, new_height), Image.Resampling.LANCZOS)

            imgtk = ImageTk.PhotoImage(image=pil_image)

            if self.camera_frame_label: # Check if label still exists
                self.camera_frame_label.imgtk = imgtk
                self.camera_frame_label.configure(image=imgtk)
        else:
            logging.warning("Failed to grab frame from camera.")
            # Optionally try to reopen or show error after multiple failures

        # Schedule the next update
        if self.camera_running:
            self.window.after(30, self._update_camera_frame) # Update ~30fps

    def stop_camera_feed(self):
         """Stops the camera feed and releases resources."""
         self.camera_running = False # Signal the loop to stop
         time.sleep(0.1) # Give the loop a moment to exit
         if self.cap:
              self.cap.release()
              self.cap = None
         # cv2.destroyAllWindows() # Don't destroy all, might affect other CV windows if used

    def stop_camera_and_go_back(self):
        """Stops camera and returns to drawing options page."""
        self.stop_camera_feed()
        self.window.unbind('s') # Unbind keys
        self.window.unbind('S')
        self.drawing_options_page() # Go back

    def capture_action_event(self, event=None):
         """Wrapper for key press event."""
         self.capture_action()

    def capture_action(self):
        """Captures the current frame and processes it."""
        if not self.camera_running or not self.cap:
            messagebox.showwarning("Capture Error", "Camera not running.")
            return

        ret, frame = self.cap.read()
        self.stop_camera_feed() # Stop feed after capture
        self.window.unbind('s') # Unbind keys
        self.window.unbind('S')


        if ret:
            try:
                # Ensure DATA_DIR exists
                os.makedirs(DATA_DIR, exist_ok=True)
                cv2.imwrite(TMP_CAPTURE_PATH, frame)
                logging.info(f"Image captured and saved to {TMP_CAPTURE_PATH}")
                self.current_image_path = TMP_CAPTURE_PATH
                # Proceed to threshold selection
                self.show_threshold_options(self.current_image_path)
            except Exception as e:
                messagebox.showerror("Save Error", f"Could not save captured image: {e}")
                self.drawing_options_page() # Go back on error
        else:
            messagebox.showerror("Capture Error", "Failed to capture frame from camera.")
            self.drawing_options_page() # Go back on error


    # --- Input Image Workflow ---
    def input_image_page(self):
        """Page for selecting an image file."""
        self.clear_frame()
        tk.Label(self.main_frame, text="Input Image to Draw", font=("Arial", 16)).pack(pady=10)

        entry_frame = tk.Frame(self.main_frame)
        entry_frame.pack(pady=5, fill='x', padx=10)
        tk.Label(entry_frame, text="Image Path:").pack(side=tk.LEFT)
        self.image_path_var = tk.StringVar()
        path_entry = tk.Entry(entry_frame, textvariable=self.image_path_var, width=50)
        path_entry.pack(side=tk.LEFT, fill='x', expand=True, padx=5)
        tk.Button(entry_frame, text="Browse...", command=self.browse_image_file).pack(side=tk.LEFT)

        # Placeholder for drag-and-drop - requires tkinterdnd2
        # drop_target = tk.Label(self.main_frame, text="Or Drag and Drop Image Here", relief="ridge", height=5, width=60)
        # drop_target.pack(pady=10)
        # drop_target.drop_target_register(DND_FILES)
        # drop_target.dnd_bind('<<Drop>>', self.handle_drop)

        tk.Button(self.main_frame, text="Process Image", command=self.process_input_image, width=20).pack(pady=10)
        tk.Button(self.main_frame, text="Back", command=self.drawing_options_page, width=20).pack(pady=10)

    def browse_image_file(self):
        """Opens file dialog to select an image."""
        filepath = filedialog.askopenfilename(
            title="Select Image to Draw",
            filetypes=[("Image Files", "*.png *.jpg *.jpeg *.bmp *.gif"), ("All Files", "*.*")]
        )
        if filepath:
            self.image_path_var.set(filepath)

    # def handle_drop(self, event): # Requires tkinterdnd2
    #     """Handles file drop event."""
    #     filepath = event.data.strip('{}') # Clean up path if needed
    #     if os.path.isfile(filepath):
    #          self.image_path_var.set(filepath)
    #     else:
    #          messagebox.showwarning("Drop Error", f"Invalid file dropped: {filepath}")


    def process_input_image(self):
        """Validates path and proceeds to threshold selection."""
        filepath = self.image_path_var.get()
        if not filepath or not os.path.isfile(filepath):
            messagebox.showerror("Error", f"Invalid or non-existent file path:\n{filepath}")
            return
        self.current_image_path = filepath
        self.show_threshold_options(self.current_image_path)


    # --- Threshold Selection Workflow ---
    def show_threshold_options(self, image_path):
        """Processes image with different thresholds and shows options."""
        self.clear_frame()
        tk.Label(self.main_frame, text="Select Drawing Style (Thresholds)", font=("Arial", 16)).pack(pady=10)

        self.threshold_options_data = {} # Clear previous results
        self.selected_threshold_option = tk.StringVar(value=None) # Variable for Radiobuttons
        self.preview_label = tk.Label(self.main_frame) # For showing edge previews
        self.preview_label.pack(pady=5)

        options_frame = tk.Frame(self.main_frame)
        options_frame.pack(pady=5)

        # Process each option in background to avoid freezing GUI
        loading_label = tk.Label(options_frame, text="Processing options...")
        loading_label.pack()
        self.window.update() # Show loading message

        threading.Thread(target=self._process_threshold_options_thread, args=(image_path, options_frame, loading_label), daemon=True).start()


    def _process_threshold_options_thread(self, image_path, options_frame, loading_label):
        """Background thread to generate commands for each threshold option."""
        results = {}
        preview_paths = {} # Store paths to preview images

        for i, (label, t1, t2) in enumerate(THRESHOLD_OPTIONS):
            logging.info(f"Processing option: {label} (t1={t1}, t2={t2})")
            preview_path = TMP_EDGE_OUTPUT_PATH.format(i) # Unique path for preview
            contours_xy, w, h = image_to_contours_internal(image_path, t1, t2, save_edge_path=preview_path)

            if contours_xy is None or w == 0 or h == 0:
                 logging.warning(f"Failed to process contours for option {label}")
                 results[label] = None # Indicate failure
                 preview_paths[label] = None
                 continue

            commands = create_drawing_paths(contours_xy, w, h, optimize_paths=True)
            if commands:
                num_commands = len(commands)
                est_time_sec = num_commands * TIME_ESTIMATE_FACTOR
                est_time_min = est_time_sec / 60
                results[label] = {
                    "commands": commands,
                    "count": num_commands,
                    "time_str": f"{est_time_min:.1f} min",
                    "t1": t1,
                    "t2": t2
                }
                preview_paths[label] = preview_path if os.path.exists(preview_path) else None
            else:
                 results[label] = None # No commands generated
                 preview_paths[label] = None
                 logging.warning(f"No commands generated for option {label}")

        # Update GUI from the main thread
        self.window.after(0, lambda: self._display_threshold_options(options_frame, loading_label, results, preview_paths))


    def _display_threshold_options(self, options_frame, loading_label, results, preview_paths):
         """Updates the GUI with the processed threshold options."""
         loading_label.destroy() # Remove loading message

         self.threshold_options_data = results # Store results
         self.edge_preview_paths = preview_paths # Store preview paths

         default_selected = False
         for i, (label, t1, t2) in enumerate(THRESHOLD_OPTIONS):
             option_data = results.get(label)
             if option_data:
                 count = option_data["count"]
                 time_str = option_data["time_str"]
                 radio_text = f"{label} (t1={t1}, t2={t2}) - Cmds: {count}, Est: {time_str}"
                 rb = tk.Radiobutton(
                     options_frame,
                     text=radio_text,
                     variable=self.selected_threshold_option,
                     value=label,
                     command=lambda l=label: self.show_edge_preview(l) # Show preview on select
                 )
                 rb.pack(anchor='w')
                 # Select the first valid option by default
                 if not default_selected:
                      self.selected_threshold_option.set(label)
                      self.show_edge_preview(label) # Show its preview
                      default_selected = True
             else:
                 # Option failed or produced no commands
                 tk.Label(options_frame, text=f"{label} (t1={t1}, t2={t2}) - No drawing generated", fg="gray").pack(anchor='w')

         # Add Confirm and Back buttons below the options
         button_frame = tk.Frame(self.main_frame)
         button_frame.pack(pady=10)
         tk.Button(button_frame, text="Confirm and Draw", command=self.confirm_and_start_drawing, width=20).pack(side=tk.LEFT, padx=5)
         # Back button should go back to the drawing options page (Capture/Input)
         tk.Button(button_frame, text="Back", command=self.drawing_options_page, width=20).pack(side=tk.LEFT, padx=5)

    def show_edge_preview(self, option_label):
         """Displays the edge preview image for the selected option."""
         preview_path = self.edge_preview_paths.get(option_label)
         if preview_path and os.path.exists(preview_path):
              try:
                   img = Image.open(preview_path)
                   # Resize for display
                   img.thumbnail((300, 300)) # Max width/height 300px
                   imgtk = ImageTk.PhotoImage(image=img)
                   self.preview_label.imgtk = imgtk
                   self.preview_label.configure(image=imgtk)
              except Exception as e:
                   logging.error(f"Error loading preview image {preview_path}: {e}")
                   self.preview_label.configure(image=None, text="Preview error") # Clear preview
         else:
              self.preview_label.configure(image=None, text="No Preview") # Clear preview


    def confirm_and_start_drawing(self):
        """Gets selected commands and starts the drawing process."""
        selected_label = self.selected_threshold_option.get()
        if not selected_label:
            messagebox.showwarning("Selection Needed", "Please select a drawing style option.")
            return

        option_data = self.threshold_options_data.get(selected_label)
        if not option_data or not option_data.get("commands"):
             messagebox.showerror("Error", "Selected option has no drawing commands.")
             return

        self.selected_commands = option_data["commands"]

        # Start drawing in a background thread
        if not self.drawing_in_progress:
             self.drawing_in_progress = True
             threading.Thread(target=self.start_drawing_process, args=(self.selected_commands,), daemon=True).start()
             self.show_drawing_progress_page(len(self.selected_commands)) # Show progress UI
        else:
             messagebox.showwarning("Busy", "Drawing already in progress.")


    # --- Drawing Execution Workflow ---
    def show_drawing_progress_page(self, total_commands):
         """Displays the progress bar and status during drawing."""
         self.clear_frame()
         tk.Label(self.main_frame, text="Drawing in Progress...", font=("Arial", 16)).pack(pady=10)

         self.status_label = tk.Label(self.main_frame, text="Starting...")
         self.status_label.pack(pady=5)

         self.progress_bar = ttk.Progressbar(self.main_frame, orient="horizontal", length=300, mode="determinate", maximum=total_commands)
         self.progress_bar.pack(pady=10)

         # Add a cancel button? (More complex: requires signaling the thread)
         # tk.Button(self.main_frame, text="Cancel Drawing", command=self.cancel_drawing).pack(pady=5)


    def update_drawing_status(self, current_command_index, total_commands, message=""):
        """Callback to update progress bar and status label from drawing thread."""
        if self.progress_bar and self.status_label:
            self.progress_bar['value'] = current_command_index
            status_text = f"Sent {current_command_index} / {total_commands} commands"
            if message:
                 status_text += f" ({message})"
            self.status_label.config(text=status_text)
            # self.window.update_idletasks() # Force update if needed, but 'after' usually handles it


    def start_drawing_process(self, commands_to_send: List[Tuple]):
        """Sends drawing commands to the robot sequentially (RUNS IN THREAD)."""
        total_commands = len(commands_to_send)
        success = True
        last_sent_point = None # Track for potential redundant moves

        if not self.connected or not self.socket:
             logging.error("Drawing started but not connected.")
             self.window.after(0, lambda: messagebox.showerror("Error", "Connection lost before drawing started."))
             self.window.after(0, self.drawing_options_page) # Go back
             self.drawing_in_progress = False
             return

        try:
            for i, (x, z, y) in enumerate(commands_to_send):
                current_point = (x, z, y)

                # --- Robot Communication Protocol ---
                # Assumes: Send command -> Wait for 'R' -> Wait for 'D'
                command_str = f"{x:.2f},{z},{y:.2f}" # Format for robot

                # Check if robot is ready / connection ok before sending? (Optional PING)

                # 1. Send Command
                if not self.send_message_internal(command_str): # Use internal send without GUI popup
                    success = False
                    self.window.after(0, lambda i=i: self.update_drawing_status(i + 1, total_commands, "Send Failed"))
                    break

                # 2. Wait for Receipt 'R'
                response_r = self.receive_message_internal(timeout=10.0) # Use internal receive
                if response_r != "R":
                    logging.error(f"Robot did not confirm receipt (R), got '{response_r}'. Stopping.")
                    success = False
                    self.window.after(0, lambda i=i, r=response_r: self.update_drawing_status(i + 1, total_commands, f"Error: No 'R' (Got {r})"))
                    break

                # 3. Wait for Done 'D'
                response_d = self.receive_message_internal(timeout=60.0) # Longer timeout for move completion
                if response_d != "D":
                    logging.error(f"Robot did not confirm completion (D), got '{response_d}'. Stopping.")
                    success = False
                    self.window.after(0, lambda i=i, d=response_d: self.update_drawing_status(i + 1, total_commands, f"Error: No 'D' (Got {d})"))
                    break
                # --- End Protocol ---

                # Update GUI progress (use window.after for thread safety)
                self.window.after(0, lambda i=i: self.update_drawing_status(i + 1, total_commands))

                last_sent_point = current_point
                # time.sleep(0.01) # Small delay if needed? Usually not necessary

        except Exception as e:
            logging.error(f"Unexpected error during drawing process: {e}")
            success = False
            self.window.after(0, lambda: self.update_drawing_status(i if 'i' in locals() else 0, total_commands, f"Error: {e}"))
            # Try to close socket gracefully on error? Depends on state.

        finally:
            # --- Send Final Position Command ---
            if success: # Only go home if drawing finished ok
                 self.window.after(0, lambda: self.update_drawing_status(total_commands, total_commands, "Drawing Done. Moving to final position..."))
                 final_x, final_z, final_y = FINAL_ROBOT_POSITION
                 command_str_final = f"{final_x:.3f},{final_z:.3f},{final_y:.3f}" # Format final command
                 logging.info(f"Sending final position command: {command_str_final}")

                 if self.send_message_internal(command_str_final):
                      response_r_final = self.receive_message_internal(timeout=10.0)
                      if response_r_final == "R":
                           response_d_final = self.receive_message_internal(timeout=60.0)
                           if response_d_final == "D":
                                logging.info("Robot reached final position.")
                                self.window.after(0, lambda: self.status_label.config(text="Drawing Complete. Robot at final position."))
                           else:
                                logging.error(f"Robot didn't confirm final move completion (D), got '{response_d_final}'")
                                self.window.after(0, lambda: self.status_label.config(text="Drawing Complete. Final move confirmation failed."))
                      else:
                           logging.error(f"Robot didn't confirm final move receipt (R), got '{response_r_final}'")
                           self.window.after(0, lambda: self.status_label.config(text="Drawing Complete. Final move send failed (No 'R')."))
                 else:
                      logging.error("Failed to send final position command.")
                      self.window.after(0, lambda: self.status_label.config(text="Drawing Complete. Failed to send final move command."))
            else:
                 # Update status if drawing failed
                 self.window.after(0, lambda: self.status_label.config(text="Drawing stopped due to error."))


            # Drawing finished or failed, reset state and return to options page
            self.drawing_in_progress = False
            self.selected_commands = None
            # Go back to the drawing options page after a short delay
            self.window.after(2000, self.drawing_options_page) # Wait 2s before going back


    # --- Internal Socket Methods (without GUI popups) ---
    def send_message_internal(self, message: str) -> bool:
        """ Sends message without triggering GUI popups on error. Returns success status. """
        if not self.connected or not self.socket: return False
        try:
            self.socket.sendall(message.encode('utf-8'))
            logging.debug(f"Sent (internal): {message}")
            return True
        except (socket.error, ConnectionResetError, socket.timeout) as e:
            logging.error(f"Send error (internal): {e}")
            self.close_socket() # Close broken socket
            return False

    def receive_message_internal(self, timeout=10.0) -> Optional[str]:
         """ Receives message without triggering GUI popups on error. Returns message or None. """
         if not self.connected or not self.socket: return None
         try:
             self.socket.settimeout(timeout)
             data = self.socket.recv(1024)
             self.socket.settimeout(None) # Reset timeout
             decoded_data = data.decode('utf-8').strip()
             logging.debug(f"Received (internal): {decoded_data}")
             return decoded_data
         except socket.timeout:
             logging.error(f"Timeout receiving message (internal)")
             # Don't necessarily close socket on timeout, maybe robot is just slow
             return None
         except (socket.error, ConnectionResetError) as e:
             logging.error(f"Receive error (internal): {e}")
             self.close_socket() # Close broken socket
             return None


    # --- Connection Handling ---
    def establish_connection(self):
        """Attempt connection (modified to use internal methods)."""
        if hasattr(self, 'connect_button'): self.connect_button.config(state=tk.DISABLED)
        host, port = (SIMULATION_HOST, SIMULATION_PORT) if self.connection_var.get() == "simulation" else (REAL_ROBOT_HOST, REAL_ROBOT_PORT)

        def connection_attempt():
            try:
                self.close_socket() # Ensure clean start
                self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                self.socket.settimeout(5)
                self.socket.connect((host, port))
                self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                self.socket.settimeout(None) # Default to blocking for operations
                logging.info(f"Connected to {host}:{port}")
                self.connected = True
                self.window.after(0, lambda: self.handle_connection_result(True))
            except (socket.error, socket.timeout, ConnectionRefusedError) as e:
                logging.error(f"Connection error: {e}")
                self.connected = False
                self.close_socket()
                self.window.after(0, lambda: self.handle_connection_result(False))
        threading.Thread(target=connection_attempt, daemon=True).start()

    def handle_connection_result(self, connected):
        """Handle connection result."""
        if hasattr(self, 'connect_button') and self.connect_button.winfo_exists():
            self.connect_button.config(state=tk.NORMAL)
        if connected:
            self.connection_established = True
            self.drawing_options_page() # Go to drawing options
        else:
            messagebox.showerror("Connection Failed", "Failed to establish connection.")

    def close_socket(self):
        """Close socket cleanly."""
        # (Implementation remains the same as previous version)
        if self.socket:
            try:
                self.socket.shutdown(socket.SHUT_RDWR)
            except (socket.error, OSError): pass # Ignore errors if already closed
            finally:
                 try: self.socket.close()
                 except (socket.error, OSError): pass
                 self.socket = None
                 self.connected = False
                 self.connection_established = False
                 logging.info("Connection closed")
        else:
             self.connected = False
             self.connection_established = False

    def close_and_return_main(self):
         """Close connection and go to main page."""
         self.close_socket()
         self.main_page()

    # --- Utility Methods ---
    def clear_frame(self):
        """Clear all widgets from the main frame."""
        # Stop camera if running when clearing frame
        if self.camera_running:
            self.stop_camera_feed()
        # Destroy widgets
        for widget in self.main_frame.winfo_children():
            widget.destroy()
        # Reset references
        self.camera_frame_label = None
        self.capture_button = None
        self.camera_back_button = None
        self.progress_bar = None
        self.status_label = None


    @staticmethod
    def run_script(script_path: str) -> bool:
        """Run a Python script (kept for calibration)."""
        # (Implementation remains the same)
        if not os.path.exists(script_path):
             logging.error(f"Script not found: {script_path}")
             return False
        try:
            logging.info(f"Running script: {script_path}")
            result = os.system(f'python "{script_path}"')
            if result != 0: logging.error(f"Script {script_path} failed with exit code {result}")
            return result == 0
        except Exception as e:
            logging.error(f"Error running script {script_path}: {e}")
            return False

    def on_window_close(self):
        """Handle window close event."""
        logging.info("Window close requested.")
        self.stop_camera_feed() # Ensure camera stops
        self.close_socket()     # Ensure socket closes
        self.window.destroy()

    # --- Calibration Methods (Keep if needed) ---
    def calibration_page(self):
         # ... (Keep calibration page logic if required) ...
         messagebox.showinfo("Info", "Calibration feature not fully integrated with new workflow yet.")
         pass

    def capture_checkerboard_image(self):
         # ... (Keep logic if required) ...
         pass

    def run_calibration_script(self):
         # ... (Keep logic if required) ...
         pass

    def test_camera(self): # Might conflict with drawing capture - review usage
         # ... (Keep logic if required, ensure it doesn't interfere) ...
         pass


# --- Main Execution ---
if __name__ == "__main__":
    # Create DATA_DIR if it doesn't exist
    os.makedirs(DATA_DIR, exist_ok=True)

    app = RUNME_GUI()
    app.window.protocol("WM_DELETE_WINDOW", app.on_window_close)
    app.window.mainloop()
--- END OF FILE: testing/test_main_gui.py ---
--- START OF FILE: testing/README.md ---
# Robot Image Drawing System

This project allows an ABB robot to draw images by converting them into a series of toolpath commands. The system features a Python-based GUI for image processing and a RAPID program for robot control, communicating via a highly efficient, low-latency TCP socket connection.

## How It Works

The system is composed of two main parts:

1.  **Python GUI (`main.py`):** This is the user-facing application and the "brain" of the operation. It acts as a TCP client.
    * It allows the user to either capture an image from a webcam or load one from a file.
    * It uses OpenCV to perform edge detection on the image, converting the visual lines into a set of (X, Y) coordinate vectors.
    * It processes these vectors, scaling them to fit the robot's physical workspace and optimizing the path to minimize unnecessary travel.
    * For each coordinate, it establishes the final `(X, Y, Z)` position for the robot's tool.
    * It then sends these commands to the robot one by one over a TCP socket.

2.  **RAPID Program (`AUTO_InputDrawing.mod`):** This program runs on the ABB robot controller and acts as the TCP server.
    * It listens for a connection from the Python application.
    * Once connected, it enters an infinite loop to receive and execute drawing commands.
    * For each command, it waits to receive a packet of data, executes the corresponding `MoveL` instruction, and sends back acknowledgements to the Python script to maintain synchronization.

---

## Setup and Installation

To run this project, you will need a Python environment with a few specific libraries installed. Using a virtual environment is highly recommended to keep dependencies isolated.

### 1. Create a Virtual Environment

Open a terminal or command prompt in the project's root directory and run the following command to create a virtual environment named `venv`:

```bash
python -m venv venv
```

### 2. Activate the Virtual Environment

Before installing packages, you need to activate the environment.

**On Windows:**
```bash
.\venv\Scripts\activate
```

**On macOS / Linux:**
```bash
source venv/bin/activate
```

Your terminal prompt should now be prefixed with `(venv)`, indicating that the virtual environment is active.

### 3. Install Required Libraries

This project requires `OpenCV` for image processing, `NumPy` for numerical operations, and `Pillow` for handling image data in the GUI. Install them using pip:

```bash
pip install opencv-python numpy Pillow
```

---

## Running the Application

1.  **Load the RAPID Program:** Load the `AUTO_InputDrawing.mod` file onto your ABB robot controller (either a real one or a virtual one in RobotStudio).
2.  **Run the RAPID Program:** Start the execution of the `main` procedure in the RAPID program. The robot will move to its home position and the program will wait for a socket connection.
3.  **Run the Python GUI:** With your virtual environment activated, run the `main.py` script from your terminal:

    ```bash
    python main.py
    ```
4.  **Connect and Draw:**
    * In the GUI, select the correct connection type (Simulation or Real Robot).
    * Click "Connect".
    * Use the test buttons to verify the connection and movement.
    * Load or capture an image, select a drawing style, and click "Confirm and Draw" to begin.

---

## The Advantage of Byte-Level Communication

For high-performance robotics, sending data as raw bytes is significantly better than higher-level methods like sending formatted strings (e.g., JSON, XML, or custom text commands).

### Why It's Better

* **Speed and Efficiency:** Raw byte communication is the fastest method possible. There is no overhead from formatting or parsing text. A floating-point number like `50.0` can be represented in just 4 bytes, whereas sending it as a string `"50.0"` takes 4 bytes plus overhead for delimiters or keys in a structured format. For an application like drawing, which can involve thousands of points, this efficiency gain is massive.
* **No Parsing Required:** When the robot controller receives a string like `"moveto(50.0, 50.0, -14.0)"`, it must spend valuable CPU cycles parsing the string: finding the numbers, converting the text characters '5', '0', '.', '0' into an actual floating-point number, and validating the format. When it receives a 12-byte packet, it can directly copy those bytes into memory and use them as three 4-byte floats. This eliminates a major source of latency.
* **Predictability and Robustness:** The protocol used in this system is rigid and predictable. Every single position command is **exactly 12 bytes**. Every acknowledgement is **exactly 1 byte**. This eliminates the synchronization problems that can occur with variable-length strings, where multiple messages can get bundled together in the TCP stream and confuse the receiver. By enforcing a strict data size, we ensure the client and server always stay in sync.

### How This System Uses It

1.  **Packing in Python:** The `main.py` script takes three Python float numbers for the `(X, Y, Z)` coordinates. It uses the `struct.pack('!fff', x, y, z)` function to convert them into a 12-byte binary representation.
    * `!`: Specifies that the data should be in network byte order (big-endian), which is a universal standard.
    * `fff`: Specifies that the data consists of three consecutive 4-byte floating-point numbers.
2.  **Sending and Receiving:** This 12-byte packet is sent over the TCP socket. The RAPID program uses `SocketReceive` with the `\ReadNoOfBytes:=12` argument, ensuring it reads the complete packet and nothing more.
3.  **Unpacking in RAPID:** The RAPID program uses the `UnpackRawBytes` instruction. Critically, it manually advances a `read_pos` pointer after each value is read, ensuring it unpacks the X, Y, and Z values from the correct locations within the 12-byte packet. This allows it to instantly reconstruct the three floating-point numbers from the raw data.

This tightly-coupled, efficient protocol is what allows the system to stream a high volume of coordinates to the robot, enabling smooth and continuous drawing motions.

--- END OF FILE: testing/README.md ---
--- START OF FILE: InputDrawing.mod ---
MODULE InputDrawing
    VAR num x;
    VAR num y;
    VAR num z;
    VAR robtarget Object_Target;
    VAR pos p1;
    VAR num target;
    VAR string data;
    VAR socketdev client_socket;
    VAR socketdev temp_socket;
    VAR robtarget targetRobTarget;
    VAR string tempX;
    VAR string tempY;
    VAR string tempZ;
    VAR num idx0;
    VAR num idx1;
    VAR num idx2;
    VAR bool success;
    CONST robtarget home1:=[[409.328464947,30.699294352,-350.922061873],[0.999898286,-0.005230998,0.00469865,0.012408784],[0,-1,1,0],[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]];
    CONST robtarget WorkSpaceCenter1:=[[75.78,312.76,9.799641871],[0.988089954,-0.00592235,0.00373461,-0.153717993],[0,0,0,0],[9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]];

    PROC main()
        MoveJ home1,v1000,z100,tool2\WObj:=Wobj_1;
        SocketConnect;

        WHILE TRUE DO
            ! socket sent in "x,z,y"
            IF SocketGetStatus(client_socket)=SOCKET_CONNECTED THEN
                SocketReceive client_socket\Str:=data,\Time:=WAIT_MAX;
                SocketSend client_socket\Str:="R";
                ConvertSocketStrToPose(data);
                ! Wait until ConvertSocketStrToPose completes
                IF success THEN
                    MoveL Offs(WorkSpaceCenter1,x,y,z),v1000,z100,tool2\WObj:=Wobj_1;                
                    SocketSend client_socket\Str:="D";
                ENDIF
            ENDIF
        ENDWHILE
    ENDPROC

    ! for real life robot station
!    PROC SocketConnect()
!        SocketCreate temp_socket;
!        SocketBind temp_socket,"192.168.125.1",1025;
!        SocketListen temp_socket;
!        SocketAccept temp_socket,client_socket,\Time:=WAIT_MAX;
!        TPWrite "Socket connection established.";
!    ENDPROC

    ! for simulation station
    
    PROC SocketConnect()
        ! Create, bind, listen, and accept the socket connection
        SocketCreate temp_socket;
        SocketBind temp_socket,"127.0.0.1",55000;
        SocketListen temp_socket;
        SocketAccept temp_socket,client_socket,\Time:=WAIT_MAX;
        TPWrite "Socket connection established.";
    ENDPROC    
    PROC ConvertSocketStrToPose(string data)
        ! Find indices of the commas
        idx1:=StrFind(data,1,",");
        idx2:=StrFind(data,idx1+1,",");

        ! Ensure all indices are valid
        IF idx1>0 AND idx2>0 THEN
            ! Extract substrings for x, y, and z
            tempX:=StrPart(data,1,idx1-1);
            tempZ:=StrPart(data,idx1+1,idx2-idx1-1);
            tempY:=StrPart(data,idx2+1,StrLen(data)-idx2);
            ! Convert strings to numeric values
            success := FALSE;
            IF StrToVal(tempX,x) AND
                           StrToVal(tempZ,z) AND
                           StrToVal(tempY,y) THEN
                success := TRUE;
            ENDIF
        ELSE
            success := FALSE;
        ENDIF
    ENDPROC

ENDMODULE
--- END OF FILE: InputDrawing.mod ---
--- START OF FILE: main.py ---
import tkinter as tk
from tkinter import messagebox, filedialog, ttk # Added ttk for progress bar
import os
import threading
import time
import logging
import socket
from concurrent.futures import ThreadPoolExecutor
from typing import List, Tuple, Optional
import cv2 # <-- Added
import numpy as np # <-- Added (likely already implicitly used by cv2)
import math
from PIL import Image, ImageTk # <-- Added
# Consider adding tkinterdnd2 for drag-and-drop later if needed
# import tkinterdnd2

# --- Drawing Logic Imports ---
# (image_to_contours_internal, scale_point_to_a4, create_drawing_paths, calculate_distance) defined below

# Configure logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")

# --- Constants (Consolidated) ---
SCRIPT_DIR = os.getenv("SCRIPT_DIR", ".") # Default to current dir if not set
DATA_DIR = os.getenv("DATA_DIR", ".") # Default to current dir

# TMP_POSITION_FILE = os.path.join(DATA_DIR, "Tmp_position.txt") # Likely not needed for drawing
TMP_CAPTURE_PATH = os.path.join(DATA_DIR, "temp_capture.png") # For captured image
TMP_EDGE_OUTPUT_PATH = os.path.join(DATA_DIR, "temp_edges_{}.png") # For edge previews

REAL_ROBOT_HOST = '192.168.125.1'
REAL_ROBOT_PORT = 1025
SIMULATION_HOST = '127.0.0.1'
SIMULATION_PORT = 55000

# Drawing Specific Constants
FINAL_ROBOT_POSITION = (0, -350, 0) # Use X, Z, Y format (X, Depth, Y) - NOTE: Z is depth here
A4_WIDTH_MM = 180  # Drawing area width
A4_HEIGHT_MM = 217 # Drawing area height
PEN_DOWN_Z = -7   # Pen down position (depth)
PEN_UP_Z = 1.3 * PEN_DOWN_Z    # Pen up position (depth)
MIN_CONTOUR_LENGTH_PX = 10 # Minimum contour length in pixels to consider

# Threshold options
THRESHOLD_OPTIONS = [
    ("Option {}".format(i), i*10, i*20) for i in range(1, 8)
]

# Time estimation factor
TIME_ESTIMATE_FACTOR = 0.02 # seconds per command estimated

SIGNATURE_POINTS = ((0, ), (0, PEN_DOWN_Z, 0))

def create_signature_commands(points):
    """Converts raw signature points (X, Z, Y) into robot commands."""
    commands = []
    if not points:
        return commands

    # 1. Move to the start of the signature with Pen Up
    start_x, _, start_y = points[0] # Use X, Y from the first point
    commands.append((start_x, PEN_UP_Z, start_y)) # Ensure pen is up

    # 2. Add all signature points as commands (using their specified Z)
    for point in points:
        commands.append(point) # Add the point (x, z, y) directly

    # 3. Lift pen after the last point
    if commands:
        last_x, _, last_y = points[-1]
        commands.append((last_x, PEN_UP_Z, last_y)) # Lift pen at the end

    return commands


# --- Drawing Helper Function ---
def calculate_distance(p1, p2):
    """Calculates Euclidean distance between two points (x, y)."""
    if p1 is None or p2 is None: return float('inf')
    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)

# --- Drawing Image Processing Functions ---
def image_to_contours_internal(image_path_or_array, threshold1, threshold2, save_edge_path=None):
    """
    Internal version: Convert image to contours using specific thresholds.
    Can accept a file path OR a pre-loaded cv2 image array.
    Does NOT print status messages.
    :param image_path_or_array: Path to the input image or numpy array (BGR or Grayscale).
    :param threshold1: Lower threshold for Canny edge detection.
    :param threshold2: Upper threshold for Canny edge detection.
    :param save_edge_path: Optional path to save the edge image for preview.
    :return: List of contours (pixel coordinates), image_width, image_height, or (None, 0, 0) on failure.
    """
    if isinstance(image_path_or_array, str):
        image = cv2.imread(image_path_or_array, cv2.IMREAD_GRAYSCALE)
    elif isinstance(image_path_or_array, np.ndarray):
        if len(image_path_or_array.shape) == 3: # BGR
            image = cv2.cvtColor(image_path_or_array, cv2.COLOR_BGR2GRAY)
        else: # Assuming already grayscale
            image = image_path_or_array
    else:
        logging.error("Invalid input type for image_to_contours_internal")
        return None, 0, 0

    if image is None:
        logging.error(f"Could not read or process image input.")
        return None, 0, 0

    image_height, image_width = image.shape[:2]
    if image_height == 0 or image_width == 0:
         logging.error("Invalid image dimensions.")
         return None, 0, 0

    blurred = cv2.GaussianBlur(image, (5, 5), 0)
    edges = cv2.Canny(blurred, threshold1, threshold2)

    if save_edge_path:
        try:
            cv2.imwrite(save_edge_path, edges)
        except Exception as e:
            logging.error(f"Failed to save edge image to {save_edge_path}: {e}")

    contours, hierarchy = cv2.findContours(edges, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)
    filtered_contours = [c for c in contours if cv2.arcLength(c, closed=False) > MIN_CONTOUR_LENGTH_PX]

    contours_xy = []
    for contour in filtered_contours:
        points = contour.squeeze().tolist()
        if not isinstance(points, list) or not points: continue # Skip empty squeezes
        if isinstance(points[0], int): # Handle single point contour
            points = [points]
        contours_xy.append([(p[0], p[1]) for p in points if isinstance(p, (list, tuple)) and len(p) == 2]) # Ensure points are valid pairs

    # Filter out empty contours that might result from the above processing
    contours_xy = [c for c in contours_xy if c]

    return contours_xy, image_width, image_height


def scale_point_to_a4(point_xy, image_width, image_height, scale_factor):
    """ Scales and transforms a single (x, y) pixel coordinate to centered A4 (mm)."""
    x_pixel, y_pixel = point_xy
    center_x_pixel = image_width / 2
    center_y_pixel = image_height / 2
    x_centered_pixel = x_pixel - center_x_pixel
    y_centered_pixel = center_y_pixel - y_pixel # Invert y-axis
    x_mm = x_centered_pixel * scale_factor
    y_mm = y_centered_pixel * scale_factor
    return (x_mm, y_mm)

def create_drawing_paths(contours_xy, image_width, image_height, optimize_paths=True):
    """ Takes list of contours (pixel coordinates), scales them, creates drawing paths."""
    if not contours_xy or image_width <= 0 or image_height <= 0:
        return []

    scale_x = A4_WIDTH_MM / image_width
    scale_y = A4_HEIGHT_MM / image_height
    scale_factor = min(scale_x, scale_y)

    scaled_contours = []
    for contour in contours_xy:
        # Ensure contour is not empty before scaling
        if not contour: continue
        scaled_contour = [scale_point_to_a4(p, image_width, image_height, scale_factor) for p in contour]
        if len(scaled_contour) >= 2:
            scaled_contours.append(scaled_contour)
        elif len(scaled_contour) == 1 :
             # Handle single points - represent as a tiny segment back to itself?
             # This ensures it gets processed for pen down/up at least.
            scaled_contours.append([scaled_contour[0], scaled_contour[0]])


    if not scaled_contours:
        return []

    ordered_contours = []
    last_point = None # Keep track of the last point of the previously added contour
    if optimize_paths:
        remaining_contours = list(scaled_contours)
        # Find a starting contour (e.g., closest to origin, or just the first)
        # For simplicity, start with the first one if available.
        if remaining_contours:
             current_contour = remaining_contours.pop(0)
             ordered_contours.append(current_contour)
             last_point = current_contour[-1]

             while remaining_contours:
                 best_dist = float('inf')
                 best_idx = -1
                 best_reversed = False

                 for i, contour in enumerate(remaining_contours):
                     start_point = contour[0]
                     end_point = contour[-1]
                     dist_start = calculate_distance(last_point, start_point)
                     dist_end = calculate_distance(last_point, end_point)

                     if dist_start < best_dist:
                         best_dist = dist_start
                         best_idx = i
                         best_reversed = False
                     if dist_end < best_dist: # Check second condition independently
                         best_dist = dist_end
                         best_idx = i
                         best_reversed = True

                 if best_idx != -1:
                      next_contour = remaining_contours.pop(best_idx)
                      if best_reversed:
                          next_contour.reverse()
                      ordered_contours.append(next_contour)
                      last_point = next_contour[-1]
                 else:
                    # Should not happen if remaining_contours is not empty, but break just in case
                   logging.warning("Path optimization loop finished unexpectedly.")
                   break # Avoid infinite loop if something goes wrong
        scaled_contours = ordered_contours # Use the optimized order
        # logging.info(f"Optimized contour drawing order.") # Reduce noise
    else:
         # If not optimizing, just use the original order
         scaled_contours = [c for c in scaled_contours] # Ensure it's a list copy if needed


    robot_commands = []
    for contour in scaled_contours:
        if not contour: continue # Should not happen, but safe check
        start_point = contour[0]
        robot_commands.append((start_point[0], PEN_UP_Z, start_point[1])) # Move pen up to start X, Y
        robot_commands.append((start_point[0], PEN_DOWN_Z, start_point[1])) # Move pen down at start X, Y

        for i in range(len(contour) - 1):
            end_point = contour[i+1]
            # Avoid duplicate commands for single-point contours handled earlier
            if end_point != contour[i]:
                robot_commands.append((end_point[0], PEN_DOWN_Z, end_point[1])) # Draw to next point

        final_point = contour[-1]
        robot_commands.append((final_point[0], PEN_UP_Z, final_point[1])) # Lift pen at the end of contour

    return robot_commands


class RUNME_GUI:
    """Main GUI application for the Robotics System."""

    def __init__(self):
        self.window = tk.Tk()
        self.window.title("Robotics Drawing GUI")
        self.main_frame = tk.Frame(self.window)
        self.main_frame.pack(pady=20, padx=20, fill="both", expand=True)

        # Connection related variables
        self.connection_var = tk.StringVar(value="simulation")
        self.socket = None
        self.connected = False
        self.connection_established = False
        # self.positions = [] # Removed, not used for drawing 

        # Camera related variables
        self.cap = None
        self.camera_running = False
        self.camera_frame_label = None # Label to display camera feed 
        self.capture_button = None
        self.camera_back_button = None

        # Drawing process related
        self.current_image_path = None # Path to the image being processed
        self.threshold_options_data = {} # Store commands for each threshold choice
        self.selected_commands = None
        self.drawing_in_progress = False
        self.cancel_requested = False # *** NEW: Flag for cancellation ***
        self.progress_bar = None
        self.status_label = None
        self.cancel_button = None # *** NEW: Reference to cancel button ***
        self.reconnect_button = None # *** NEW: Reference to reconnect button ***

        self.last_drawing_status = {
            "total_commands": 0,
            "completed_commands": 0,
            "status": "None",  # e.g., "Completed", "Cancelled", "Connection Lost", "Protocol Error", "Failed to Resume"
            "error_message": ""
        }
        
        # Resume related variables
        self.resume_needed = False # *** NEW: Flag indicating connection was lost during drawing ***
        self.resume_commands = None # *** NEW: Store remaining commands ***
        self.resume_total_original_commands = 0 # *** NEW: Store original total for progress bar ***
        self.resume_start_index_global = 0 # *** NEW: Store the global index to resume from ***

        self.main_page()

    # --- Page Navigation ---
    def main_page(self):
        """Main application page."""
        self.clear_frame()
        tk.Label(self.main_frame, text="Robotics Drawing System", font=("Arial", 16)).pack(pady=10)
        tk.Button(self.main_frame, text="Setup Connection & Draw",
                  command=self.connection_setup_page, width=30).pack(pady=5)
        # tk.Button(self.main_frame, text="Camera Calibration", # Keep if needed 
        #           command=self.calibration_page, width=30).pack(pady=5) 
        tk.Button(self.main_frame, text="Exit",
                  command=self.on_window_close, width=30).pack(pady=5) # Call proper close handler

    def connection_setup_page(self):
        """Page for setting up robot connection."""
        # Simplified - remove radio buttons if only one target is needed often
        # Or keep as is 
        self.clear_frame()
        tk.Label(self.main_frame, text="Robot Connection Setup", font=("Arial", 16)).pack(pady=10)

        connection_frame = tk.Frame(self.main_frame)
        connection_frame.pack(pady=10)
        tk.Radiobutton(connection_frame, text=f"Simulation: {SIMULATION_HOST}:{SIMULATION_PORT}",
                       variable=self.connection_var, value="simulation").pack(anchor='w')
        tk.Radiobutton(connection_frame, text=f"Real Robot: {REAL_ROBOT_HOST}:{REAL_ROBOT_PORT}",
                       variable=self.connection_var, value="real").pack(anchor='w')

        # *** NEW: Conditionally show Connect or Reconnect & Resume button ***
        self.connect_button = tk.Button(self.main_frame, text="Connect", command=self.establish_connection, width=20)
        self.reconnect_button = tk.Button(self.main_frame, text="Reconnect & Resume", command=self.establish_connection, width=20) # Same command

        if self.resume_needed:
            self.reconnect_button.pack(pady=5)
            tk.Label(self.main_frame, text="Connection lost during last drawing. Reconnect to resume.", fg="orange").pack()
        else:
            self.connect_button.pack(pady=5)

        tk.Button(self.main_frame, text="Back", command=self.main_page, width=20).pack(pady=5) # Go back to main page

    def drawing_options_page(self):
        """Page shown after successful connection."""
        if not self.connection_established:
            messagebox.showerror("Connection Required", "Please establish connection first.")
            self.connection_setup_page()
            return

        self.clear_frame()
        tk.Label(self.main_frame, text="Robot Drawing Options", font=("Arial", 16)).pack(pady=10)
        conn_type = "Simulation" if self.connection_var.get() == "simulation" else "Real Robot"
        tk.Label(self.main_frame, text=f"Connected to: {conn_type}", fg="green").pack(pady=5)
        last_status = self.last_drawing_status["status"]
        if last_status not in ["None", "Completed"]:
            status_frame = tk.Frame(self.main_frame, relief=tk.RIDGE, borderwidth=2)
            status_frame.pack(pady=10, padx=10, fill='x')
            tk.Label(status_frame, text="Previous Drawing Status:", font=("Arial", 10, "bold")).pack(anchor='w')
            status_text = f"Status: {last_status}"
            if self.last_drawing_status["total_commands"] > 0:
                status_text += f" (Stopped at command {self.last_drawing_status['completed_commands'] + 1}" \
                                f" of {self.last_drawing_status['total_commands']})"
            tk.Label(status_frame, text=status_text).pack(anchor='w', padx=5)
            if self.last_drawing_status["error_message"]:
                tk.Label(status_frame, text=f"Details: {self.last_drawing_status['error_message']}", wraplength=400).pack(anchor='w', padx=5)


        tk.Button(self.main_frame, text="Capture Image to Draw",
                  command=self.capture_image_page, width=30).pack(pady=5) # Changed command
        tk.Button(self.main_frame, text="Input Image to Draw",
                  command=self.input_image_page, width=30).pack(pady=5) # Changed command
        tk.Button(self.main_frame, text="Disconnect",
                  command=self.close_and_return_main, width=30).pack(pady=5)

    # --- Capture Image Workflow ---
    def capture_image_page(self):
        """Opens camera view for capturing."""
        self.clear_frame()
        tk.Label(self.main_frame, text="Camera View", font=("Arial", 16)).pack(pady=5)

        self.camera_frame_label = tk.Label(self.main_frame)
        self.camera_frame_label.pack(pady=10)

        button_frame = tk.Frame(self.main_frame)
        button_frame.pack(pady=5)

        self.capture_button = tk.Button(button_frame, text="Capture (S)", command=self.capture_action)
        self.capture_button.pack(side=tk.LEFT, padx=5)
        self.camera_back_button = tk.Button(button_frame, text="Back", command=self.stop_camera_and_go_back)
        self.camera_back_button.pack(side=tk.LEFT, padx=5)

        # Bind 's' key
        self.window.bind('s', self.capture_action_event)
        self.window.bind('S', self.capture_action_event) # Also capital S

        self.start_camera_feed()

    def start_camera_feed(self):
        """Starts displaying the camera feed."""
        if self.camera_running: return # Already running

        try:
            self.cap = cv2.VideoCapture(0) # Use default camera 
            if not self.cap.isOpened():
                messagebox.showerror("Camera Error", "Could not open camera.")
                self.stop_camera_and_go_back()
                return
            self.camera_running = True
            self._update_camera_frame() # Start the update loop
        except Exception as e:
             messagebox.showerror("Camera Error", f"Error initializing camera: {e}")
             self.stop_camera_and_go_back()


    def _update_camera_frame(self):
        """Internal method to continuously update the camera feed label."""
        if not self.camera_running or not self.cap:
             return

        ret, frame = self.cap.read()
        if ret:
            # Convert frame for Tkinter
            cv_image = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            pil_image = Image.fromarray(cv_image)
            # Resize image to fit nicely (optional)
            # aspect_ratio = pil_image.width / pil_image.height 
            # new_height = 300
            # new_width = int(aspect_ratio * new_height) 
            # pil_image = pil_image.resize((new_width, new_height), Image.Resampling.LANCZOS) 

            imgtk = ImageTk.PhotoImage(image=pil_image)

            if self.camera_frame_label: # Check if label still exists
                self.camera_frame_label.imgtk = imgtk
                self.camera_frame_label.configure(image=imgtk)
        else:
            logging.warning("Failed to grab frame from camera.")
            # Optionally try to reopen or show error after multiple failures

        # Schedule the next update
        if self.camera_running:
            self.window.after(30, self._update_camera_frame) # Update ~30fps

    def stop_camera_feed(self):
         """Stops the camera feed and releases resources."""
         self.camera_running = False # Signal the loop to stop
         time.sleep(0.1) # Give the loop a moment to exit
         if self.cap:
              self.cap.release()
              self.cap = None
         # cv2.destroyAllWindows() # Don't destroy all, might affect other CV windows if used 

    def stop_camera_and_go_back(self):
        """Stops camera and returns to drawing options page."""
        self.stop_camera_feed()
        self.window.unbind('s') # Unbind keys
        self.window.unbind('S')
        self.drawing_options_page() # Go back

    def capture_action_event(self, event=None):
         """Wrapper for key press event."""
         self.capture_action()

    def capture_action(self):
        """Captures the current frame and processes it."""
        if not self.camera_running or not self.cap:
            messagebox.showwarning("Capture Error", "Camera not running.")
            return

        ret, frame = self.cap.read()
        self.stop_camera_feed() # Stop feed after capture
        self.window.unbind('s') # Unbind keys
        self.window.unbind('S')


        if ret:
            try:
                # Ensure DATA_DIR exists
                os.makedirs(DATA_DIR, exist_ok=True)
                cv2.imwrite(TMP_CAPTURE_PATH, frame)
                logging.info(f"Image captured and saved to {TMP_CAPTURE_PATH}")
                self.current_image_path = TMP_CAPTURE_PATH
                # Proceed to threshold selection
                self.show_threshold_options(self.current_image_path)
            except Exception as e:
                messagebox.showerror("Save Error", f"Could not save captured image: {e}")
                self.drawing_options_page() # Go back on error
        else:
            messagebox.showerror("Capture Error", "Failed to capture frame from camera.")
            self.drawing_options_page() # Go back on error


    # --- Input Image Workflow ---
    def input_image_page(self):
        """Page for selecting an image file."""
        self.clear_frame()
        tk.Label(self.main_frame, text="Input Image to Draw", font=("Arial", 16)).pack(pady=10)

        entry_frame = tk.Frame(self.main_frame)
        entry_frame.pack(pady=5, fill='x', padx=10)
        tk.Label(entry_frame, text="Image Path:").pack(side=tk.LEFT)
        self.image_path_var = tk.StringVar()
        path_entry = tk.Entry(entry_frame, textvariable=self.image_path_var, width=50)
        path_entry.pack(side=tk.LEFT, fill='x', expand=True, padx=5)
        tk.Button(entry_frame, text="Browse...", command=self.browse_image_file).pack(side=tk.LEFT)

        # Placeholder for drag-and-drop - requires tkinterdnd2
        # drop_target = tk.Label(self.main_frame, text="Or Drag and Drop Image Here", relief="ridge", height=5, width=60) 
        # drop_target.pack(pady=10)
        # drop_target.drop_target_register(DND_FILES) 
        # drop_target.dnd_bind('<<Drop>>', self.handle_drop) 

        tk.Button(self.main_frame, text="Process Image", command=self.process_input_image, width=20).pack(pady=10)
        tk.Button(self.main_frame, text="Back", command=self.drawing_options_page, width=20).pack(pady=10)

    def browse_image_file(self):
        """Opens file dialog to select an image."""
        filepath = filedialog.askopenfilename(
            title="Select Image to Draw", 
            filetypes=[("Image Files", "*.png *.jpg *.jpeg *.bmp *.gif"), ("All Files", "*.*")]
        )
        if filepath:
            self.image_path_var.set(filepath)

    # def handle_drop(self, event): # Requires tkinterdnd2 
    #     """Handles file drop event.""" 
    #     filepath = event.data.strip('{}') # Clean up path if needed 
    #     if os.path.isfile(filepath):
    #          self.image_path_var.set(filepath) 
    #     else: 
    #          messagebox.showwarning("Drop Error", f"Invalid file dropped: {filepath}") 


    def process_input_image(self):
        """Validates path and proceeds to threshold selection."""
        filepath = self.image_path_var.get()
        if not filepath or not os.path.isfile(filepath):
            messagebox.showerror("Error", f"Invalid or non-existent file path:\n{filepath}")
            return
        self.current_image_path = filepath
        self.show_threshold_options(self.current_image_path)


    # --- Threshold Selection Workflow ---
    def show_threshold_options(self, image_path):
        """Processes image with different thresholds and shows options."""
        self.clear_frame()
        tk.Label(self.main_frame, text="Select Drawing Style (Thresholds)", font=("Arial", 16)).pack(pady=10)

        self.threshold_options_data = {} # Clear previous results
        self.selected_threshold_option = tk.StringVar(value=None) # Variable for Radiobuttons
        self.preview_label = tk.Label(self.main_frame) # For showing edge previews
        self.preview_label.pack(pady=5)

        options_frame = tk.Frame(self.main_frame)
        options_frame.pack(pady=5)

        # Process each option in background to avoid freezing GUI
        loading_label = tk.Label(options_frame, text="Processing options...")
        loading_label.pack()
        self.window.update() # Show loading message 

        threading.Thread(target=self._process_threshold_options_thread, args=(image_path, options_frame, loading_label), daemon=True).start()


    def _process_threshold_options_thread(self, image_path, options_frame, loading_label):
        """Background thread to generate commands for each threshold option."""
        results = {}
        preview_paths = {} # Store paths to preview images

        for i, (label, t1, t2) in enumerate(THRESHOLD_OPTIONS):
            logging.info(f"Processing option: {label} (t1={t1}, t2={t2})")
            preview_path = TMP_EDGE_OUTPUT_PATH.format(i) # Unique path for preview
            contours_xy, w, h = image_to_contours_internal(image_path, t1, t2, save_edge_path=preview_path)

            if contours_xy is None or w == 0 or h == 0:
                 logging.warning(f"Failed to process contours for option {label}")
                 results[label] = None # Indicate failure 
                 preview_paths[label] = None
                 continue

            commands = create_drawing_paths(contours_xy, w, h, optimize_paths=True)
            if commands:
                num_commands = len(commands)
                est_time_sec = num_commands * TIME_ESTIMATE_FACTOR
                est_time_min = est_time_sec / 60
                results[label] = {
                    "commands": commands, 
                    "count": num_commands,
                    "time_str": f"{est_time_min:.1f} min",
                    "t1": t1,
                    "t2": t2
                }
                preview_paths[label] = preview_path if os.path.exists(preview_path) else None
            else:
                 results[label] = None # No commands generated
                 preview_paths[label] = None
                 logging.warning(f"No commands generated for option {label}")

        # Update GUI from the main thread
        self.window.after(0, lambda: self._display_threshold_options(options_frame, loading_label, results, preview_paths))


    def _display_threshold_options(self, options_frame, loading_label, results, preview_paths):
         """Updates the GUI with the processed threshold options."""
         loading_label.destroy() # Remove loading message

         self.threshold_options_data = results # Store results
         self.edge_preview_paths = preview_paths # Store preview paths

         default_selected = False
         for i, (label, t1, t2) in enumerate(THRESHOLD_OPTIONS):
             option_data = results.get(label)
             if option_data:
                 count = option_data["count"]
                 time_str = option_data["time_str"]
                 radio_text = f"{label} (t1={t1}, t2={t2}) - Cmds: {count}, Est: {time_str}"
                 rb = tk.Radiobutton(
                    options_frame, 
                 text=radio_text,
                 variable=self.selected_threshold_option,
                 value=label,
                 command=lambda l=label: self.show_edge_preview(l) # Show preview on select
                 )
                 rb.pack(anchor='w')
                 # Select the first valid option by default
                 if not default_selected:
                      self.selected_threshold_option.set(label)
                      self.show_edge_preview(label) # Show its preview
                      default_selected = True
             else:
                 # Option failed or produced no commands
                 tk.Label(options_frame, text=f"{label} (t1={t1}, t2={t2}) - No drawing generated", fg="gray").pack(anchor='w')

         # Add Confirm and Back buttons below the options
         button_frame = tk.Frame(self.main_frame)
         button_frame.pack(pady=10)
         tk.Button(button_frame, text="Confirm and Draw", command=self.confirm_and_start_drawing, width=20).pack(side=tk.LEFT, padx=5)
         # Back button should go back to the drawing options page (Capture/Input)
         tk.Button(button_frame, text="Back", command=self.drawing_options_page, width=20).pack(side=tk.LEFT, padx=5)

    def show_edge_preview(self, option_label):
         """Displays the edge preview image for the selected option."""
         preview_path = self.edge_preview_paths.get(option_label)
         if preview_path and os.path.exists(preview_path):
              try:
                   img = Image.open(preview_path)
                   # Resize for display
                   img.thumbnail((300, 300)) # Max width/height 300px
                   imgtk = ImageTk.PhotoImage(image=img)
                   self.preview_label.imgtk = imgtk
                   self.preview_label.configure(image=imgtk)
              except Exception as e:
                   logging.error(f"Error loading preview image {preview_path}: {e}")
                   self.preview_label.configure(image=None, text="Preview error") # Clear preview
         else:
              self.preview_label.configure(image=None, text="No Preview") # Clear preview


    def confirm_and_start_drawing(self):
        """Gets selected commands and starts the drawing process."""
        selected_label = self.selected_threshold_option.get()
        if not selected_label:
            messagebox.showwarning("Selection Needed", "Please select a drawing style option.")
            return

        option_data = self.threshold_options_data.get(selected_label)
        if not option_data or not option_data.get("commands"):
             messagebox.showerror("Error", "Selected option has no drawing commands.")
             return

        self.selected_commands = option_data["commands"]

        # Start drawing in a background thread
        if not self.drawing_in_progress:
             self.drawing_in_progress = True
             self.cancel_requested = False # Ensure cancel flag is reset
             self.resume_needed = False # Reset resume flag
             # *** Pass the full command list including signature ***
             full_command_list = self.selected_commands + create_signature_commands(SIGNATURE_POINTS)
             threading.Thread(target=self.run_drawing_loop, args=(full_command_list,), daemon=True).start()
             self.show_drawing_progress_page(len(full_command_list)) # Show progress UI with total commands
        else:
            messagebox.showwarning("Busy", "Drawing already in progress.")


    # --- Drawing Execution Workflow ---
    def show_drawing_progress_page(self, total_commands, current_progress=0, status_message="Starting..."):
         """Displays the progress bar and status during drawing."""
         self.clear_frame()
         tk.Label(self.main_frame, text="Drawing in Progress...", font=("Arial", 16)).pack(pady=10)

         self.status_label = tk.Label(self.main_frame, text=status_message)
         self.status_label.pack(pady=5)

         self.progress_bar = ttk.Progressbar(self.main_frame, orient="horizontal", length=300, mode="determinate", maximum=total_commands, value=current_progress)
         self.progress_bar.pack(pady=10)

         # *** NEW: Add Cancel Button ***
         self.cancel_button = tk.Button(self.main_frame, text="Cancel Drawing", command=self.request_cancel_drawing)
         self.cancel_button.pack(pady=5)


    def update_drawing_status(self, current_command_index, total_commands, message=""):
        """Callback to update progress bar and status label from drawing thread."""
        if self.progress_bar and self.progress_bar.winfo_exists():
            self.progress_bar['value'] = current_command_index
        if self.status_label and self.status_label.winfo_exists():
            status_text = f"Sent {current_command_index} / {total_commands} commands"
            if message:
                 status_text += f" ({message})"
            self.status_label.config(text=status_text)
            # self.window.update_idletasks() # Force update if needed, but 'after' usually handles it 

    def request_cancel_drawing(self):
        """Sets the cancellation flag when the Cancel button is pressed."""
        if self.drawing_in_progress:
            logging.info("Cancel requested by user.")
            self.cancel_requested = True
            if self.cancel_button and self.cancel_button.winfo_exists():
                self.cancel_button.config(text="Cancelling...", state=tk.DISABLED)
            if self.status_label and self.status_label.winfo_exists():
                self.status_label.config(text="Cancellation requested...")

    def _send_final_position_and_cleanup(self, success_message, failure_message):
        """Sends the robot to the final position and cleans up state. Runs in drawing thread."""
        logging.info("Attempting to move robot to final position.")
        final_x, final_z, final_y = FINAL_ROBOT_POSITION
        command_str_final = f"{final_x:.3f},{final_z:.3f},{final_y:.3f}" # Format final command 

        move_ok = False
        if self.connected and self.socket:
            if self.send_message_internal(command_str_final):
                response_r_final = self.receive_message_internal(timeout=20.0)
                if response_r_final == "R":
                    response_d_final = self.receive_message_internal(timeout=30.0) # Longer timeout for final move
                    # if response_d_final == "D":
                    #     logging.info("Robot reached final position.") #
                    #     move_ok = True
                    # else:
                    #     logging.error(f"Robot didn't confirm final move completion (D), got '{response_d_final}'") #
                else:
                    logging.error(f"Robot didn't confirm final move receipt (R), got '{response_r_final}'") #
            else:
                logging.error("Failed to send final position command.") #

        # Update GUI status based on move success/failure and original reason
        final_status = ""
        if move_ok:
            final_status = f"{success_message} Robot at final position."
        else:
            final_status = f"{failure_message} Failed to reach final position."

        self.last_drawing_status["status"] = success_message # Use the original reason (Completed, Cancelled, etc.)
        self.last_drawing_status["error_message"] = "" if move_ok else "Failed to reach final position."

        self.window.after(0, lambda fs=final_status: self.update_final_status(fs))

        # --- Final Cleanup ---
        self.drawing_in_progress = False
        self.selected_commands = None
        self.cancel_requested = False
        # Reset resume state ONLY if the process finished (successfully or cancelled), not on disconnect
        if not self.resume_needed: # Don't clear resume state if we dropped connection
            self.resume_commands = None
            self.resume_total_original_commands = 0
            self.resume_start_index_global = 0

        # Go back to the drawing options page after a short delay
        self.window.after(2000, self.drawing_options_page) # Wait 2s before going back 

    def update_final_status(self, message):
        """Updates the status label safely from the main thread."""
        if self.status_label and self.status_label.winfo_exists():
            self.status_label.config(text=message)
        if self.cancel_button and self.cancel_button.winfo_exists():
            self.cancel_button.pack_forget() # Remove cancel button

    def run_drawing_loop(self, commands_to_send: List[Tuple], start_index=0):
        """Sends drawing commands sequentially (RUNS IN THREAD). Handles cancel and resume."""
        total_commands = len(commands_to_send) + start_index # Total original commands for progress bar max
        current_command_global_index = start_index # Start from the correct global index
        commands_processed_in_this_run = 0

        # If resuming, ensure progress page reflects original total and current progress
        if start_index > 0:
            self.window.after(0, lambda: self.show_drawing_progress_page(total_commands, current_command_global_index, "Resuming drawing..."))
            self.window.after(0, lambda: self.update_drawing_status(current_command_global_index, total_commands, "Resuming..."))
        else:
            self.window.after(0, lambda: self.update_drawing_status(0, total_commands, "Starting..."))

        try:
            # Iterate through the commands *starting from the correct index*
            for i, (x, z, y) in enumerate(commands_to_send[start_index:], start=start_index):
                current_command_global_index = i + 1 # Overall progress index (1-based)

                # *** NEW: Check for cancellation before sending ***
                if self.cancel_requested:
                    logging.info(f"Cancellation detected at command {current_command_global_index}.")
                    self.window.after(0, lambda idx=i: self.update_drawing_status(idx, total_commands, "Cancelling..."))
                    self._send_final_position_and_cleanup("Drawing Cancelled.", "Drawing Cancelled.")
                    return # Exit the thread

                # Format command
                command_str = f"{x:.2f},{z},{y:.2f}" # Format for robot 
                logging.debug(f"Sending command {current_command_global_index}/{total_commands}: {command_str}")

                # --- Robot Communication Protocol ---
                # 1. Send Command
                if not self.send_message_internal(command_str): # If send fails...
                    # *** NEW: Handle connection loss ***
                    logging.error(f"Connection lost while sending command {current_command_global_index}. Preparing to resume.")
                    self.resume_needed = True
                    # Save state relative to the *original full list*
                    self.resume_commands = commands_to_send # Keep the full list
                    self.resume_start_index_global = i # Save the index of the command that failed (0-based)
                    self.resume_total_original_commands = total_commands
                    
                    self.last_drawing_status["total_commands"] = total_commands
                    self.last_drawing_status["completed_commands"] = i # Command i failed
                    self.last_drawing_status["status"] = "Connection Lost"
                    self.last_drawing_status["error_message"] = f"Lost connection before sending command {i+1}"
                    
                    self.window.after(0, lambda idx=i: self.update_drawing_status(idx, total_commands, "Connection Lost!"))
                    self.window.after(1000, self.connection_setup_page) # Go to connection page to allow reconnect
                    self.drawing_in_progress = False # Allow reconnect button to work
                    return # Exit thread

                # 2. Wait for Receipt 'R'
                response_r = self.receive_message_internal(timeout=20.0) # If receive fails...
                if response_r is None: # Check for None indicating socket error/timeout
                    # *** NEW: Handle connection loss ***
                    logging.error(f"Connection lost while waiting for 'R' after command {current_command_global_index}. Preparing to resume.")
                    self.resume_needed = True
                    self.resume_commands = commands_to_send
                    self.resume_start_index_global = i # Resume from the command that wasn't fully confirmed
                    self.resume_total_original_commands = total_commands
                    self.window.after(0, lambda idx=i: self.update_drawing_status(idx, total_commands, "Connection Lost! (No 'R')"))
                    self.window.after(1000, self.connection_setup_page)
                    self.drawing_in_progress = False
                    return # Exit thread
                elif response_r != "R":
                    error_msg = f"Robot did not confirm receipt (R) for command {current_command_global_index}, got '{response_r}'."
                    logging.error(error_msg + " Preparing to resume.") # Changed log message
                    # *** NEW: Prepare for resume on 'R' error ***
                    self.resume_needed = True
                    self.resume_commands = commands_to_send
                    self.resume_start_index_global = i # Resume from the command that failed confirmation
                    self.resume_total_original_commands = total_commands
                    # Update last status
                    self.last_drawing_status["total_commands"] = total_commands
                    self.last_drawing_status["completed_commands"] = i
                    self.last_drawing_status["status"] = "Protocol Error (R)"
                    self.last_drawing_status["error_message"] = error_msg
                    # *** End NEW ***
                    self.window.after(0, lambda idx=i, r=response_r: self.update_drawing_status(idx, total_commands, f"Error: No 'R' (Got {r}). Reconnect to resume."))
                    # *** NEW: Go to connection page instead of cleanup ***
                    self.window.after(1000, self.connection_setup_page)
                    self.drawing_in_progress = False
                    return # Exit thread

                # 3. Wait for Done 'D'
                response_d = self.receive_message_internal(timeout=30.0) # Longer timeout for move completion 
                if response_d is None: # Check for None indicating socket error/timeout
                    # *** NEW: Handle connection loss ***
                    logging.error(f"Connection lost while waiting for 'D' after command {current_command_global_index}. Preparing to resume.")
                    self.resume_needed = True
                    self.resume_commands = commands_to_send
                    # Resume from the *next* command since this one completed movement but confirmation failed
                    self.resume_start_index_global = i + 1
                    self.resume_total_original_commands = total_commands
                    self.window.after(0, lambda idx=i: self.update_drawing_status(idx + 1, total_commands, "Connection Lost! (No 'D')")) # Show progress for completed command
                    self.window.after(1000, self.connection_setup_page)
                    self.drawing_in_progress = False
                    return # Exit thread
                # elif response_d != "D":
                #     error_msg = f"Robot did not confirm completion (D) for command {current_command_global_index}, got '{response_d}'."
                #     logging.error(error_msg + " Preparing to resume.") # Changed log message
                #     # *** NEW: Prepare for resume on 'D' error ***
                #     self.resume_needed = True
                #     self.resume_commands = commands_to_send
                #     # Resume from the *next* command since 'R' was received, but 'D' failed
                #     self.resume_start_index_global = i + 1
                #     self.resume_total_original_commands = total_commands
                #     # Update last status
                #     self.last_drawing_status["total_commands"] = total_commands
                #     self.last_drawing_status["completed_commands"] = i + 1 # Command i movement likely completed
                #     self.last_drawing_status["status"] = "Protocol Error (D)"
                #     self.last_drawing_status["error_message"] = error_msg
                #     # *** End NEW ***
                #     self.window.after(0, lambda idx=i, d=response_d: self.update_drawing_status(idx + 1, total_commands, f"Error: No 'D' (Got {d}). Reconnect to resume."))
                #     # *** NEW: Go to connection page instead of cleanup ***
                #     self.window.after(1000, self.connection_setup_page)
                #     self.drawing_in_progress = False
                #     return # Exit thread

                commands_processed_in_this_run += 1
                # Update GUI progress
                self.window.after(0, lambda idx=current_command_global_index: self.update_drawing_status(idx, total_commands)) # 

            # If the loop completes without cancellation or error
            logging.info("All drawing commands sent successfully.")
            self.window.after(0, lambda: self.update_drawing_status(total_commands, total_commands, "Drawing Complete."))
            self._send_final_position_and_cleanup("Drawing Complete.", "Drawing Complete.")

        except Exception as e:
            logging.error(f"Unexpected error during drawing process: {e}", exc_info=True) # 
            # Attempt to update status, but might fail if GUI is gone
            try:
                self.window.after(0, lambda idx=current_command_global_index: self.update_drawing_status(idx, total_commands, f"Runtime Error: {e}")) # 
            except tk.TclError:
                logging.error("GUI already closed during error handling.")
            # Don't try to move robot here, connection state unknown
            self.drawing_in_progress = False
            self.cancel_requested = False
            # Keep resume state in case it was a connection error leading to this exception
            # self.window.after(2000, self.drawing_options_page) # Don't automatically go back on unexpected error


    # --- Internal Socket Methods (without GUI popups) ---
    def send_message_internal(self, message: str) -> bool:
        """ Sends message without triggering GUI popups on error. Returns success status. """
        if not self.connected or not self.socket: return False
        try:
            self.socket.sendall(message.encode('utf-8'))
            logging.debug(f"Sent (internal): {message}")
            return True
        except (socket.error, ConnectionResetError, BrokenPipeError, socket.timeout) as e: # Added BrokenPipeError
            logging.error(f"Send error (internal): {e}")
            self.handle_connection_loss() # Use centralized handler
            return False

    def receive_message_internal(self, timeout=20.0) -> Optional[str]:
         """ Receives message without triggering GUI popups on error. Returns message or None. """
         if not self.connected or not self.socket: return None
         try:
             self.socket.settimeout(timeout)
             data = self.socket.recv(1024)
             self.socket.settimeout(None) # Reset timeout
             if not data: # Socket closed gracefully by peer
                 logging.warning("Receive error (internal): Connection closed by peer.")
                 self.handle_connection_loss()
                 return None
             decoded_data = data.decode('utf-8').strip()
             logging.debug(f"Received (internal): {decoded_data}")
             return decoded_data
         except socket.timeout:
             logging.error(f"Timeout receiving message (internal)")
             # Don't necessarily close socket on timeout, maybe robot is just slow
             # Consider if timeout should also trigger resume logic if it happens during drawing
             # For now, returning None might lead to connection loss handling higher up if expected msg isn't received.
             return None # Indicate timeout specifically? For now, None leads to resume check.
         except (socket.error, ConnectionResetError, BrokenPipeError) as e: # Added BrokenPipeError
             logging.error(f"Receive error (internal): {e}")
             self.handle_connection_loss() # Use centralized handler
             return None

    def handle_connection_loss(self):
        """Centralized handling of connection loss detection."""
        logging.warning("Connection lost detected.")
        was_connected = self.connected
        self.close_socket() # Close the broken socket and update flags
        # *** If connection lost DURING drawing, set resume flag ***
        # The resume flag is set higher up in the run_drawing_loop when errors occur
        # Here, we just ensure the socket is closed.
        # If we weren't drawing, we don't need to set resume_needed.
        # We might need to inform the user if they were connected but not drawing.
        if was_connected and not self.drawing_in_progress and not self.resume_needed:
             # Use 'after' to schedule GUI updates from the main thread
            self.window.after(0, lambda: messagebox.showinfo("Connection Lost", "Robot connection lost."))
            # Potentially navigate back to connection page if not already there
            # Check current page? For simplicity, assume user might need to reconnect manually.


    # --- Connection Handling ---
    def establish_connection(self):
        """Attempt connection (modified to use internal methods and handle resume)."""
        if hasattr(self, 'connect_button') and self.connect_button.winfo_exists(): self.connect_button.config(state=tk.DISABLED)
        if hasattr(self, 'reconnect_button') and self.reconnect_button.winfo_exists(): self.reconnect_button.config(state=tk.DISABLED)

        host, port = (SIMULATION_HOST, SIMULATION_PORT) if self.connection_var.get() == "simulation" else (REAL_ROBOT_HOST, REAL_ROBOT_PORT)

        def connection_attempt():
            try:
                self.close_socket() # Ensure clean start
                self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                self.socket.settimeout(5)
                self.socket.connect((host, port))
                self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                self.socket.settimeout(None) # Default to blocking for operations
                logging.info(f"Connected to {host}:{port}")
                self.connected = True
                # *** Call handle_connection_result via 'after' ***
                self.window.after(0, lambda: self.handle_connection_result(True))
            except (socket.error, socket.timeout, ConnectionRefusedError) as e:
                logging.error(f"Connection error: {e}")
                self.connected = False # Ensure flag is false before calling handler
                self.close_socket() # Clean up socket if connection failed
                # *** Call handle_connection_result via 'after' ***
                self.window.after(0, lambda: self.handle_connection_result(False))
        threading.Thread(target=connection_attempt, daemon=True).start()

    def handle_connection_result(self, connected):
        """Handle connection result and trigger resume if needed."""
        # Re-enable buttons safely
        if hasattr(self, 'connect_button') and self.connect_button.winfo_exists():
            self.connect_button.config(state=tk.NORMAL)
        if hasattr(self, 'reconnect_button') and self.reconnect_button.winfo_exists():
            self.reconnect_button.config(state=tk.NORMAL)

        if connected:
            self.connection_established = True
            # *** NEW: Check if resume is needed ***
            if self.resume_needed and self.resume_commands is not None:
                logging.info("Reconnection successful. Preparing to resume drawing.")
                # Move to final position BEFORE resuming
                self.move_to_final_before_resume() # This will start resume loop after move
            else:
                # Normal connection, go to drawing options
                self.drawing_options_page() # Go to drawing options
        else:
            if self.resume_needed:
                messagebox.showerror("Reconnection Failed", "Failed to reconnect. Cannot resume the previous drawing.")
                # Reset resume state as we can't continue
                self.resume_needed = False
                self.resume_commands = None
                self.resume_total_original_commands = 0
                self.resume_start_index_global = 0
                # Update last status to reflect the failed resume attempt
                self.last_drawing_status["status"] = "Resume Failed"
                self.last_drawing_status["error_message"] = "Could not reconnect to robot."
                # Go back to drawing options page after acknowledging the error
                self.drawing_options_page()
            else:
                messagebox.showerror("Connection Failed", "Failed to establish connection.")
            # Stay on connection page if it was a normal connection attempt that failed
    def move_to_final_before_resume(self):
        """Sends robot to FINAL_ROBOT_POSITION and then starts resume. Runs in thread."""
        def move_and_resume_thread():
            logging.info("Moving robot to FINAL_ROBOT_POSITION before resuming...")
            self.show_drawing_progress_page(self.resume_total_original_commands, self.resume_start_index_global, "Moving to resume position...")

            final_x, final_z, final_y = FINAL_ROBOT_POSITION
            command_str_final = f"{final_x:.3f},{final_z:.3f},{final_y:.3f}"
            move_ok = False
            if self.connected and self.socket:
                if self.send_message_internal(command_str_final):
                    response_r = self.receive_message_internal(timeout=5.0)
                    if response_r == "R":
                        response_d = self.receive_message_internal(timeout=5.0)
                        # if response_d == "D":
                        #     logging.info("Robot reached FINAL_ROBOT_POSITION.")
                        #     move_ok = True
                        # else: logging.error("Failed to get 'D' confirmation for pre-resume move.")
                    else: logging.error("Failed to get 'R' confirmation for pre-resume move.")
                else: logging.error("Failed to send pre-resume move command.")

            if move_ok:
                 # *** Start the drawing loop from the resume point ***
                 logging.info(f"Starting resume from command index {self.resume_start_index_global}")
                 self.drawing_in_progress = True # Set flag before starting thread
                 self.cancel_requested = False # Ensure cancel flag is reset
                 # We don't reset resume_needed here, it's reset on completion/cancel
                 # Use the stored remaining commands and start index
                 # NOTE: run_drawing_loop expects the FULL command list and the start_index
                 self.run_drawing_loop(self.resume_commands, self.resume_start_index_global)
                 # The run_drawing_loop itself now handles progress updates etc.
            else: # if move_ok is False
                error_msg = "Failed to move robot to safe resume position."
                logging.error(error_msg + " Cannot resume automatically, but allowing retry.")
                # *** NEW: Update status but keep resume state ***
                self.last_drawing_status["status"] = "Resume Failed (Pre-move)"
                self.last_drawing_status["error_message"] = error_msg
                # Keep previous command counts if available
                # Ensure resume_needed remains True, DO NOT reset resume variables here
                # *** End NEW ***
                self.window.after(0, lambda: messagebox.showwarning("Resume Warning", error_msg + "\nConnection might be unstable. You can try 'Reconnect & Resume' again."))
                # Reset drawing flag
                self.drawing_in_progress = False
                # *** NEW: Go back to connection page to allow retry ***
                self.window.after(1000, self.connection_setup_page)

        # Start the move and potential resume in a new thread
        threading.Thread(target=move_and_resume_thread, daemon=True).start()


    def close_socket(self):
        """Close socket cleanly and update flags."""
        if self.socket:
            try:
                self.socket.shutdown(socket.SHUT_RDWR)
            except (socket.error, OSError): pass # Ignore errors if already closed
            finally:
                try: self.socket.close()
                except (socket.error, OSError): pass
                self.socket = None
                logging.info("Socket closed")
        # Always update flags when this is called
        self.connected = False
        self.connection_established = False
        # Do NOT reset drawing_in_progress or resume flags here,
        # they are managed by the drawing loop and connection loss handler

    def close_and_return_main(self):
         """Close connection and go to main page."""
         # If drawing was in progress, should we cancel it first?
         # For simplicity now, just close the socket. Active drawing will fail.
         self.close_socket()
         # Reset any pending resume state if user explicitly disconnects
         self.resume_needed = False
         self.resume_commands = None
         self.resume_total_original_commands = 0
         self.resume_start_index_global = 0
         self.main_page()

    # --- Utility Methods ---
    def clear_frame(self):
        """Clear all widgets from the main frame."""
        # Stop camera if running when clearing frame
        if self.camera_running:
            self.stop_camera_feed()
        # Destroy widgets
        for widget in self.main_frame.winfo_children():
            widget.destroy()
        # Reset references to GUI elements that are destroyed
        self.camera_frame_label = None
        self.capture_button = None
        self.camera_back_button = None
        self.progress_bar = None
        self.status_label = None
        self.cancel_button = None
        self.connect_button = None
        self.reconnect_button = None
        self.preview_label = None


    @staticmethod
    def run_script(script_path: str) -> bool:
        """Run a Python script (kept for calibration)."""
        # (Implementation remains the same) 
        if not os.path.exists(script_path):
             logging.error(f"Script not found: {script_path}")
             return False
        try:
            logging.info(f"Running script: {script_path}")
            result = os.system(f'python "{script_path}"')
            if result != 0: logging.error(f"Script {script_path} failed with exit code {result}")
            return result == 0
        except Exception as e:
            logging.error(f"Error running script {script_path}: {e}")
            return False

    def on_window_close(self):
        """Handle window close event."""
        logging.info("Window close requested.")
        self.cancel_requested = True # Signal drawing thread to stop if running
        self.stop_camera_feed() # Ensure camera stops
        self.close_socket()     # Ensure socket closes
        # Give threads a moment to potentially react to cancel_requested or socket closure
        time.sleep(0.2)
        self.window.destroy()


# --- Main Execution ---
if __name__ == "__main__":
    # Create DATA_DIR if it doesn't exist 
    os.makedirs(DATA_DIR, exist_ok=True)

    app = RUNME_GUI()
    app.window.protocol("WM_DELETE_WINDOW", app.on_window_close)
    app.window.mainloop()
--- END OF FILE: main.py ---
--- START OF FILE: .gitignore ---
temp_edges_0.png
temp_edges_1.png
temp_edges_2.png
temp_edges_3.png
temp_edges_4.png
temp_edges_5.png
temp_edges_6.png
--- END OF FILE: .gitignore ---
--- START OF FILE: README.md ---
# Robot Arm Auto Drawing

This repository contains a Python script that automates the process of GOFA CRB 15000 drawing any image input in the system. Please unpack pack and go file of robot studio and use the main.py script to run the program.

Rapid code of the Drawing_1 station (after unpack pack and go) must be run before running main.py

## Showcase

| H1 | H2 |
|:---|:---|
|  |  |
|  |  |


## Setup and Installation

To run this project, you will need a Python environment with a few specific libraries installed. Using a virtual environment is highly recommended to keep dependencies isolated.

### 1. Create a Virtual Environment

Open a terminal or command prompt in the project's root directory and run the following command to create a virtual environment named `venv`:

```bash
python -m venv venv
```

### 2. Activate the Virtual Environment

Before installing packages, you need to activate the environment.

**On Windows:**
```bash
.\venv\Scripts\activate
```

**On macOS / Linux:**
```bash
source venv/bin/activate
```

Your terminal prompt should now be prefixed with `(venv)`, indicating that the virtual environment is active.

### 3. Install Required Libraries

This project requires `OpenCV` for image processing, `NumPy` for numerical operations, and `Pillow` for handling image data in the GUI. Install them using pip:

```bash
pip install opencv-python numpy Pillow
```

---

## Running the Application

1.  **Load the RAPID Program:** Load the `AUTO_InputDrawing.mod` file onto your ABB robot controller (either a real one or a virtual one in RobotStudio).
2.  **Run the RAPID Program:** Start the execution of the `main` procedure in the RAPID program. The robot will move to its home position and the program will wait for a socket connection.
3.  **Run the Python GUI:** With your virtual environment activated, run the `main.py` script from your terminal:

    ```bash
    python main.py
    ```
4.  **Connect and Draw:**
    * In the GUI, select the correct connection type (Simulation or Real Robot).
    * Click "Connect".
    * Use the test buttons to verify the connection and movement.
    * Load or capture an image, select a drawing style, and click "Confirm and Draw" to begin.

--- END OF FILE: README.md ---
